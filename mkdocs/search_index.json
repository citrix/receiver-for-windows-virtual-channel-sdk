{
    "docs": [
        {
            "location": "/", 
            "text": "Citrix Virtual Channel SDK for Citrix Receiver for Windows\n\n\nThe Citrix Virtual Channel Software Development Kit (SDK) provides\nsupport for writing server-side applications and client-side drivers for\nadditional virtual channels using the ICA protocol. The server-side\nvirtual channel applications are on XenApp or XenDesktop servers. This\nversion of the SDK provides support for writing new virtual channels for\nReceiver for Windows. If you want to write virtual drivers for other\nclient platforms, contact Citrix.\n\n\nThe Virtual Channel SDK provides:\n\n\n\n\n\n\nThe Citrix Virtual Driver Application Programming Interface (VDAPI)\nused with the virtual channel functions in the Citrix Server API SDK\n(WFAPI SDK) to create new virtual channels. The virtual channel\nsupport provided by VDAPI is designed to make writing your own virtual\nchannels easier.\n\n\n\n\n\n\nThe Windows Monitoring API, which enhances the visual experience and\nsupport for third-party applications integrated with ICA.\n\n\n\n\n\n\nWorking source code for several virtual channel sample programs that\ndemonstrate programming techniques.\n\n\n\n\n\n\nThe Virtual Channel SDK requires the WFAPI SDK to write the server\nside of the virtual channel.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#citrix-virtual-channel-sdk-for-citrix-receiver-for-windows", 
            "text": "The Citrix Virtual Channel Software Development Kit (SDK) provides\nsupport for writing server-side applications and client-side drivers for\nadditional virtual channels using the ICA protocol. The server-side\nvirtual channel applications are on XenApp or XenDesktop servers. This\nversion of the SDK provides support for writing new virtual channels for\nReceiver for Windows. If you want to write virtual drivers for other\nclient platforms, contact Citrix.  The Virtual Channel SDK provides:    The Citrix Virtual Driver Application Programming Interface (VDAPI)\nused with the virtual channel functions in the Citrix Server API SDK\n(WFAPI SDK) to create new virtual channels. The virtual channel\nsupport provided by VDAPI is designed to make writing your own virtual\nchannels easier.    The Windows Monitoring API, which enhances the visual experience and\nsupport for third-party applications integrated with ICA.    Working source code for several virtual channel sample programs that\ndemonstrate programming techniques.    The Virtual Channel SDK requires the WFAPI SDK to write the server\nside of the virtual channel.", 
            "title": "Citrix Virtual Channel SDK for Citrix Receiver for Windows"
        }, 
        {
            "location": "/system-requirements/", 
            "text": "System Requirements\n\n\nCitrix Virtual Channel SDK can be installed on systems supported by\nCitrix Receiver for Windows. You can build the virtual drivers and\napplications on any platform. To run, they require a server running\nXenApp or XenDesktop.\n\n\nDevelopment Environment Requirements\n\n\nUse Microsoft Visual Studio 2008 and .NET 4.0. Server-side development\nalso requires the WFAPI SDK.\n\n\nAlthough the compiler software packages include C++, only C code is used\nin this SDK. This SDK has not been tested with any other compilers or\nany other combinations.\n\n\nExecution Environment Requirements\n\n\nServer requirement\n\n\nThe Windows Virtual Channel SDK is supported on Citrix XenApp 6.5 (or later) and Citrix XenDesktop 7.6 (or later)\n\n\nClient Requirement\n\n\nCitrix Receiver for Windows 4.7", 
            "title": "System Requirements"
        }, 
        {
            "location": "/system-requirements/#system-requirements", 
            "text": "Citrix Virtual Channel SDK can be installed on systems supported by\nCitrix Receiver for Windows. You can build the virtual drivers and\napplications on any platform. To run, they require a server running\nXenApp or XenDesktop.", 
            "title": "System Requirements"
        }, 
        {
            "location": "/system-requirements/#development-environment-requirements", 
            "text": "Use Microsoft Visual Studio 2008 and .NET 4.0. Server-side development\nalso requires the WFAPI SDK.  Although the compiler software packages include C++, only C code is used\nin this SDK. This SDK has not been tested with any other compilers or\nany other combinations.", 
            "title": "Development Environment Requirements"
        }, 
        {
            "location": "/system-requirements/#execution-environment-requirements", 
            "text": "", 
            "title": "Execution Environment Requirements"
        }, 
        {
            "location": "/system-requirements/#server-requirement", 
            "text": "The Windows Virtual Channel SDK is supported on Citrix XenApp 6.5 (or later) and Citrix XenDesktop 7.6 (or later)", 
            "title": "Server requirement"
        }, 
        {
            "location": "/system-requirements/#client-requirement", 
            "text": "Citrix Receiver for Windows 4.7", 
            "title": "Client Requirement"
        }, 
        {
            "location": "/build-process/", 
            "text": "Build Process\n\n\nThe source supplied in this SDK includes MAKEFILEs for use with the\nMicrosoft NMAKE utility. You run the utility from a command prompt. The\nclient-side virtual driver is not designed to be built using the visual\ninterface of Microsoft Visual C/C++, or with the visual interface of\nVisual Studio. See the Microsoft documentation for details about NMAKE.\n\n\nYou can build both server and client examples for Win32 at one time\nusing the supplied batch file \nsrc\\examples\\vc\\buildit.bat\n.\n\n\nCompiled object files are placed in the \nobj\\retail\n subfolder of the\nplatform folder; for example, \nwin32\\obj\\retail\n.\n\n\nThe components can also be built with debugging information turned on.\nThe output directory changes to \nobj\\debug\n for debug objects.", 
            "title": "Build Process"
        }, 
        {
            "location": "/build-process/#build-process", 
            "text": "The source supplied in this SDK includes MAKEFILEs for use with the\nMicrosoft NMAKE utility. You run the utility from a command prompt. The\nclient-side virtual driver is not designed to be built using the visual\ninterface of Microsoft Visual C/C++, or with the visual interface of\nVisual Studio. See the Microsoft documentation for details about NMAKE.  You can build both server and client examples for Win32 at one time\nusing the supplied batch file  src\\examples\\vc\\buildit.bat .  Compiled object files are placed in the  obj\\retail  subfolder of the\nplatform folder; for example,  win32\\obj\\retail .  The components can also be built with debugging information turned on.\nThe output directory changes to  obj\\debug  for debug objects.", 
            "title": "Build Process"
        }, 
        {
            "location": "/using-the-sdk/", 
            "text": "Using the Virtual Channel SDK\n\n\nBefore using the Virtual Channel SDK, install the WFAPI SDK. You must\nhave administrator privileges.\n\n\n\n\n\n\nSet up the compiler environment for each of the target platforms\n    you build. The MAKEFILEs use variables to find the compiler and\n    its files. Normally, installing the compiler sets these variables\n    as environment variables; for example, \nvsvars32.bat\n. If not, you\n    can set the environment variables or set the defaults in the\n    MAKEFILE \nsrc\\examples\\build\\user.mak\n.\n\n\n\n\n\n\nFrom the Start menu, choose Run, and then type \nc:\\path\\vcsdk\n,\n    where \nc:\\path\n is the path to the Virtual Channel SDK \n.zip\n\n    extracted package.\n\n\n\n\n\n\nLog off and log on or set the \nCLNTROOT\n environment variable to the\n    directory where the SDK resides (for example, \nc:\\path\\vcsdk\n).", 
            "title": "Using the Virtual Channel SDK"
        }, 
        {
            "location": "/using-the-sdk/#using-the-virtual-channel-sdk", 
            "text": "Before using the Virtual Channel SDK, install the WFAPI SDK. You must\nhave administrator privileges.    Set up the compiler environment for each of the target platforms\n    you build. The MAKEFILEs use variables to find the compiler and\n    its files. Normally, installing the compiler sets these variables\n    as environment variables; for example,  vsvars32.bat . If not, you\n    can set the environment variables or set the defaults in the\n    MAKEFILE  src\\examples\\build\\user.mak .    From the Start menu, choose Run, and then type  c:\\path\\vcsdk ,\n    where  c:\\path  is the path to the Virtual Channel SDK  .zip \n    extracted package.    Log off and log on or set the  CLNTROOT  environment variable to the\n    directory where the SDK resides (for example,  c:\\path\\vcsdk ).", 
            "title": "Using the Virtual Channel SDK"
        }, 
        {
            "location": "/using-example-programs/", 
            "text": "Using Example Programs\n\n\nThe example programs included with the Virtual Channel SDK are\nbuildable, working virtual channels. Use these examples to:\n\n\n\n\nVerify your Virtual Channel SDK is correct by building a known working example program.\n\n\nProvide working examples of code that can be modified to suit your requirements.\n\n\nExplore the features and functionality provided in the Virtual Channel SDK.\n\n\n\n\nEach of these example programs comprises a client virtual driver and a\nserver application. The server-side application is run from the command\nline within an ICA session. A single virtual channel comprises an\napplication pair.\n\n\nThe example programs included with the Virtual Channel SDK are:\n\n\n\n\nPing: Records the round-trip delay time for a test packet sent over a virtual channel.\n\n\nMix: Demonstrates a mechanism to call functions (for example, to get the time of day) on a remote client.\n\n\nOver: Simple asynchronous application that demonstrates how to code an application where the server must receive a response from the client asynchronously, and where the type of packet being sent to the client is different from the type received.\n\n\n\n\nEach example includes a description of the program, packet format, and\nother necessary information.\n\n\nPing\n\n\nPing is a simple program that records the round-trip delay time\nfor a test packet sent over a virtual channel. The server sends a packet to the client and the\nclient responds with a packet containing the time it received the original packet from the\nserver. This sequence is repeated a specified number of times, and then the program displays\nthe round-trip time for each ping and the average round-trip delay time.\n\n\nFor this example, there is no significant difference between a BEGIN\npacket and an END packet. The two types of packets are provided as an example for\nwriting your own virtual channel protocols.\n\n\nThis program demonstrates:\n\n\n\n\nHow to transfer data synchronously. The sequence of events is:\n{SrvWrite, ClntRead, ClntWrite, SrvRead} {SrvWrite, ClntRead} {...}.\nThe server waits for the client to reply before sending the next\npacket.\n\n\nHow to read parameter data (in this case, the number of times to send\npackets to the client) from the Module.ini files.\n\n\n\n\nPacket Format\n\n\nThe following packet is exchanged between the client and the server.\n\n\ntypedef struct  PING  {\nUSHORT          uSign;              // Signature\nUSHORT          uType;              // Type, BEGIN or END, from server\nUSHORT          uLen;               // Packet length from server\nUSHORT          uCounter;           // Sequencer\nULONG           ulServerMS;         // Server millisecond clock\nULONG           ulClientMS;         // Client millisecond clock\n} PING, *PPING;\n\n\n\n\n\nMix\n\n\nMix demonstrates a mechanism that can be used to call functions on a remote client (for example to get the time of day). This program demonstrates an extensible scheme for making function calls from the server to the client that allows the server to specify when it expects a response from the client and when it does not. This method can increase performance, because the server does not have to constantly wait for a reply from the client.\n\n\nThe server calls a series of simple functions:\n\n\n\n\nAdd No: Add two numbers and return the sum as the return value.\n\n\nDisp Str: Write a string to the log file. There is no return value (write-only function).\n\n\nGettime: Read the client time and return it as the return value.\n\n\n\n\nThe actual implementation of these functions is on the client side. The server conditionally waits for the response from the client, depending on the function being executed. For example, the server waits for the result of the AddNo or Gettime function, but not the write- only function DispStr, which returns no result.\n\n\nPacket Format\n\n\ntypedef struct MIXHEAD {                                        \nUSHORT          uType               // Packet type\nUSHORT          uFunc;              // Index of Function\nULONG           uLen;               // Length of data\nUSHORT          fRetReq;            // True if return\nULONG           dwRetVal;           // Return Value from client\nUSHORT          dwLen1;             // length of data\nUSHORT          dwLen2;             // length of data\n}       MIXHEAD, \\*PMIXHEAD;                 \n\n\n\n\n\nThe data consists of the above structure followed by the arguments to\nthe function being called. uLen is the total length of the data being\nsent, including the arguments. DwLen1 is the length of the data pointed\nto by a pointer argument.\n\n\nSequence of Events\n\n\nThis figure illustrates the sequence of events that occurs when you use\nthe Mix program, starting at the top.\n\n\n\n\nOver\n\n\nOver is a simple asynchronous application. It demonstrates how to code an application in which the server must receive a response from the client asynchronously, and the type of packet being sent to the client is different from the type received.\n\n\nWhen the Over program begins, it:\n\n\n\n\nSpawns a thread that waits for a response from the client.\n\n\nBegins sending data packets with sequence numbers to the client.\n\n\n(After sending the last packet of data) sends a packet with a sequence number of NO_MORE_DATA, and then closes the connection.\n\n\n\n\nThe client receives packets and inspects the sequence number. For\nevery sequence number divisible by 10, the client increases the\nsequence number by 7 and sends a response to the server. These numbers\nare chosen arbitrarily to demonstrate that the client can\nasynchronously send data to the server at any time.\n\n\nThe packet type used to send data from the server to the client is\ndifferent from the packet type used to receive data from the client.\n\n\nPacket Format - From Server to Client\n\n\n            typedef struct OVER  {\n             USHORT         uSign;              // Signature\n             USHORT         uType;              // Type, BEGIN or END, from server\n             USHORT         uLen;               // Packet length from server\n             USHORT         uCounter;           // Sequencer\n             ULONG          ulServerMS;         // Server millisecond clock\n            } OVER, *POVER;\n\n\n\n\n\nPacket Format - From Client to Server\n\n\n            typedef struct DRVRESP  {\n             USHORT         uType;              // Type OVERFLOW_JUMP from client\n             USHORT         uLen;               // Packet length from client\n             USHORT         uCounter;           // Sequencer\n            } DRVRESP, *PDRVRESP;\n\n\n\n\n\nSequence of Events\n\n\nThis figure illustrates the sequence of events that occurs when you\nuse the Over program, starting at the top.\n\n\n\n\nBuilding Examples\n\n\nBuilding a Server- side Example using NMAKE\n\n\n\n\n\n\nChange to the vcsdk\\src\\examples\\vc\\server\\ subdirectory.\n\n\n\n\n\n\nAt a command prompt, type \nNMAKE clean all\n.\n\n\n\n\n\n\nTo build an individual server example, run NMAKE from the example subdirectory. \n\n\n\n\n\n\nBuilding a Server- side Example using Visual Studio or .NET\n\n\n\n\n\n\nCreate a new Win32 console project. Citrix recommends that the\n    project name be associated with the example (for\n    example, ctxping). You can set the location of the project to the\n    src\\examples\\vc\\server directory so that the .c source files\n    are readily available.\n\n\n\n\n\n\nAdd the following directories to include the search path of the C++\n    preprocessor in the project settings (where vcsdk is the directory\n    for the Virtual Channel SDK):\n\n\n\n\nvcsdk\\src\\examples\\vc\\shared\\inc\n\n\nvcsdk\\src\\shared\\inc\\Citrix\n\n\n\n\n\n\n\n\nPoint to the wfapi include and library paths. Open file wfapi.mak\n    from vcsdk installation path\\src\\examples\\build.\n\n\n\n\nSet WFAPILIB to the full path of WFAPI lib directory.\n\n\nSet WFAPIINC to the full path of WFAPI include directory. \n\n\n\n\n\n\n\n\nThe WFAPI SDK installs Wfapi.lib into the designated library directory. \n\n\nBuilding a Client- side Example for Win 32 using NMAKE\n\n\n\n\n\n\nBrowse to the Visual Studios Common tools folder and run \nvsvars32.bat\n.\n\n\n\n\n\n\nOpen user.mak in the \n\\src\\examples\\build directory.\n\n\n\n\nSet the paths corresponding to your installation of Visual Studio\n\n\nSet the paths corresponding to your installation of the Windows SDK.\n\n\nSet the paths corresponding to your installation of WFAPI.\n\n\n\n\n\n\n\n\nOpen wfapi.mak in the \n\\src\\examples\\build directory. Set the paths\n    corresponding to your installation of WFAPI.\n\n\n\n\n\n\nChange to directory \n\\src\\examples\\vc.\n\n\n\n\n\n\nFor each example you want to build, type \n\n\n\n\ncd client\\example\n\n\nnmake win32.cln\n\n\n\n\n\n\n\n\nTo build the retail modules, type \nnmake win32\n\n\n\n\n\n\nTo build the debug modules, type \nnmake win32.dbg\n\n\n\n\n\n\nBuilding a Client-side Example for Win 32 using Visual Studio\n\n\n\n\n\n\nFor all platforms, the virtual channel driver DLL must export the\n    Load function. You can do this with either a .DEF file or by\n    specifying it as a compiler option in your Visual Studio\n    project setting.\n\n\n\n\n\n\nMake sure the calling convention is set to stdcall.\n\n\n\n\n\n\nPreparing and Deploying a Virtual Driver\n\n\nBefore installing a virtual driver on a client, copy the virtual\ndriver for the platform to the client device and configure the client\nMSI.\n\n\n\n\n\n\nCopy the appropriate virtual driver for the platform to the\n    directory on the device where the client is installed. The virtual\n    driver is the .Dll file in\n    \n\\src\\examples\\vc\\client\\driver\\platform\\obj\\retail\n, where\n    driver is \nvdmix\n, \nvdover\n, or \nvdping\n. The default installation\n    directory is \n%SystemDrive%\\Program Files\\Citrix\\ICA Client\n.\n\n\n\n\n\n\nOpen the standard client MSI package with the Microsoft packaging\n    tools (for example, Orca in the Windows Installer SDK).\n\n\n\n\n\n\nAdd the virtual channel .DLL to the MSI package.\n\n\n\n\n\n\nModify the Configuration Storage file \n/configuration/module.ini\n.\n\n\n\n\n\n\n\n\nWarning\nEditing the Registry incorrectly can cause serious problems\nthat may require you to reinstall your operating system. Citrix cannot\nguarantee that problems resulting from the incorrect use of Registry\nEditor can be solved. Use the Registry Editor at your own risk. Be\nsure to back up the registry before you edit it.\n\n\n\n\n\n\n\n\nLocate the VirtualDriverEx string REG_SZ value in the HKEY_LOCAL_MACHINE\\SOFTWARE\\Citrix\\ICAClient\\Engine\\Configuration\\Advanced\\Modules\\ICA3.0 key. Append the name of the virtual driver to the end of this line, for example: \nVirtualDriverEx = VDPING\n.\n\n\nUnder the \nHKEY_LOCAL_MACHINE\\SOFTWARE\\Citrix\\ICAClient\\Engine\\Configuration\\Advanced\\Modules\n key, create a new \n key, where \n; is VDMIX, VDOVER, VDPING. For VDPING, the section would be: \nHKEY_LOCAL_MACHINE\\SOFTWARE\\Citrix\\ICAClient\\Engine\\Configuration\\Advanced\\Modules\\ VDPING\n. Add the following string REG_SZ values under the above key:\n\n\n\n\nDriverName          = VDPING.DLL\nDriverNameWin16     = VDPINGW.DLL\nDriverNameWin32     = VDPINGN.DLL\nPingCount           = 3\n\n\n\n\n\nThe client engine uses DriverName, DriverNameWin16, and\nDriverNameWin32 to determine the module filename to load for each\nplatform. PingCount is a tunable parameter used by the Ping virtual\nchannel.\n\n\n. Repackage the MSI for deployment. \n\n\nTo deploy the MSI\n\n\nDeploy your MSI package with Windows Active Directory Services or\nMicrosoft Systems Management Server. See your Windows or Systems\nManagement Server documentation for more information. No further\nconfiguration is necessary.\n\n\nTo add a virtual channel after installation\n\n\nBecause the Module.ini file is installed in the registry, modifying\nthe file after installation has no effect. To add a virtual channel\nafter installation, use the Group Policy template or change the\nregistry keys corresponding to those in the Module.ini file at the\nfollowing registry location:\n\n\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Citrix\\ICAClient\\Engine\\Configuration\\Advanced\\Modules\n\n\n\n\n\nRunning an Example Virtual Channel\n\n\n\n\n\n\nOn a client configured with the client-side example, connect to a\n    server running XenApp/XenDesktop with the associated\n    server-side example.\n\n\n\n\n\n\nWithin the ICA session, run the server-side executable.\n\n\n\n\n\n\nThe server-side example queries the client-side virtual driver, and\nthen displays the driver information. Use the -d parameter to display detailed information.\n\n\nFor Ping only: CTXPING sends PingCount separate pings. PingCount has a\ndefault value of three, but can be set in the [Ping] section of the\nModule.ini file. Each ping consists of a BEGIN packet and an END\npacket.\n\n\nDebugging a Win32 virtual driver\n\n\nUse the TRACE feature to log events on the client. To enable the TRACE\nstatements, you must build the debug version of the virtual driver. When\nthe debug module is installed on the client, the TRACE statements write\nthe debug information to a file.\n\n\nAt run time, you can specify which class and event flags to trace. This\nallows you to trace only the sections you need, minimizing performance\ndegradation.\n\n\nThe class flag for virtual channels is 00000080. For the complete list\nof class and event flags, see Logflags.h (in src\\inc).\n\n\n\n\n\n\nCompile the debug version of the virtual driver for the\n    client platform.\n\n\n\n\n\n\nIf it is running, close the client on the client device.\n\n\n\n\n\n\nCopy the compiled debug version of the library into the directory on\n    the client device where the client is installed. For example, for\n    the Ping example, copy VdpingN.dll to \\Citrix\\ICA Client.\n\n\n\n\n\n\nChange to the directory containing the client and type:\n\n\n\n\n\n\nwfcrun32 connection /c:xxxxxxxx /e:yyyyyyyy /logfile:filename \n\n\n\n\n\nwhere:\n\n connection is the name of the connection in Remote Application\nManager.\n\n xxxxxxxx are the event flags you want to log.\n\n yyyyyyyy are the class flags you want to log.\n\n filename is the relative path of the file to which you want to save\nthe log.\n\n\nThe client stores the Appsrv.ini file in each user\u2019s profile directory.\nWhen starting the ICA session with event logging, add\n\n/iniappsrv:%userprofile%\\\u201dapplication data\u201d\\icaclient\\appsrv.ini\n to\nthe end of the command line above.\n\n\nDeploying Client Virtual Channels Remotely\n\n\nTo deploy virtual channels remotely, make changes based on the following\nadministrative template (.adm) file.\n\n\nCustomVC is a placeholder for the channel name of the virtual channel.\n\n\n;Group Policy template for Citrix Windows Receiver.\n;Citrix Windows Receiver Client Extensions template\n;Description:\n;This file is provided as a base for third-party extensions\n;to the Citrix Windows Receiver client.\n; Copyright (C) Citrix Systems, Inc. All Rights Reserved.\n;\nCLASS MACHINE\nCATEGORY !!Citrix \n    CATEGORY !!ICAClient\n        CATEGORY !!Third Party\n          #if version \n= 4\n          EXPLAIN !!Explain_Third Party\n          #endif\n          ; Remotely define virtual channel \n          POLICY !!Policy_CustomVirtualChannel\n            EXPLAIN !!Explain_CustomVirtualChannel\n            KEYNAME \nSoftware\\Policies\\Citrix\\ICA Client\\Engine\\Lockdown \n            Profiles\\All Regions\\Lockdown\\Virtual Channels\\Third \n            Party\\CustomVC\n\n            VALUENAME \nVCEnable\n\n            VALUEON \ntrue,false\n VALUEOFF \nfalse\n ACTIONLISTON \n            KEYNAME \nSoftware\\Citrix\\ICA Client\\Engine\\Lockdown \n            Profiles\\All Regions\\Lockdown\\Virtual Channels\\Third \n            Party\\CustomVC\n\n                    VALUENAME \nVCEnable\n \n                    VALUE    \n\n                    KEYNAME \nSoftware\\Citrix\\ICA \n            Client\\Engine\\Configuration\\Advanced\\Modules\\ICA 3.0\n\n                    VALUENAME \nVirtualDriverEx\n \n                    VALUE \nCustomVC\n\n                    KEYNAME \nSoftware\\Citrix\\ICA            Client\\Engine\\Configuration\\Advanced\\Modules\\CustomVC\n\n                    VALUENAME \nDriverName\n \n                    VALUE \nUnsupported\n \n                    KEYNAME \nSoftware\\Citrix\\ICA\n            Client\\Engine\\Configuration\\Advanced\\Modules\\CustomVC\n \n                    VALUENAME \nDriverNameWin16\n\n                    VALUE \nUnsupported\n \n                    KEYNAME \nSoftware\\Citrix\\ICA\n            Client\\Engine\\Configuration\\Advanced\\Modules\\CustomVC\n \n                    VALUENAME \nDriverNameWin32\n \n                    VALUE \nVDCustomVC.DLL\n\n                END ACTIONLISTON \n                ACTIONLISTOFF\n                    KEYNAME \nSoftware\\Citrix\\ICA \n            Client\\Engine\\Configuration\\Advanced\\Modules\\ICA 3.0\n\n                    VALUENAME \nVirtualDriverEx\n \n                    VALUE \n\n                    END ACTIONLISTOFF\n            END POLICY \n        END CATEGORY\n    END CATEGORY \nEND CATEGORY\n[strings]\nCitrix=\nCitrix Components\n \nICAClient=\nPresentation Server Client\n \nThird Party=\nExtensions\n\nExplain_Third Party=\nThese policies control extensions to the standard Citrix Presentation Server Client.\n\nPolicy_CustomVirtualChannel=\nAdditional Virtual Channel\n\nExplain_CustomVirtualChannel=\n This policy controls a virtual\nchannel.\\n\\nSupplier:\\nMy\ncompany.\\n\\nReference:\n       \n\n\n\n\n\nAdministrative Template Changes for Ping Example\n\n\nFor the ping virtual channel example, edit the .adm template file as\nfollows (changes in the text are in boldface).\n\n\n\n\nNote\nThe Memory INI functions require the lines in the example\nreferencing VCEnable. Every parameter used by the virtual channel must\nappear in this file. The client uses these to place security\nrestrictions on the virtual channels.\n\n\n\n\n\n\n;\n;   Group policy template for Citrix Windows Recevier Client\n;   Ping virtual channel example template\n;   Description;\n;   A Group Policy template to remotely configure the Ping Virtual Channel\nCLASS MACHINE\nCATEGORY !! Citrix\n    CATEGORY !! ICAClient\n        CATEGORY !!Third Party\n            #if version \n=4\n              EXPLAIN !!Explain_Thrid Party\n            #endif\n            ;\n            ;   Remotely configure the Ping Virtual Channel\n            ;\n            POLICY !!Policy_PingVirtualChannel\n              EXPLAIN !!Explain_PingVirtualChannel\n              KEYNAME \nSoftware\\Policies\\Citrix\\ICA Client\\Engine\\Lockdown \n              Profiles\\All Regions\\Lockdown\\Virtual Channels\\Third Party\\ping\n\n                VALUENAME \nVCEnable\n\n                VALUEON\ntrue,false\n\n                VALUEOFF\nfalse\n\n              ACTIONLISTON\n                KEYNAME\nSoftware\\Citrix\\ICA Client\\Engine\\Lockdown\\\n                Profiles\\All Regions\\Lockdown\\Virtual Channels\\Third\n                Party\\ping\n\n                  VALUENAME \nVCEnable\n\n                  VALUE \n\n                KEYNAME\nSoftware\\Citrix\\ICA Client\\Engine\\Configuration\\Advanced\\Module\\ICA 3.0\n\n                  VALUENAME \nVirtualDriverEx\n\n                  VALUE \nping\n\n                KEYNAME\nSoftware\\Citrix\\ICA Client\\Engine\\Configuration\\Advanced\\Modules\\ping\n\n                  VALUENAME \nDriverName\n\n                  VALUE \nUnsupported\n   \n                KEYNAME \nSoftware\\Citrix\\ICA Client\\Engine\\Configuration\\ Advanced\\Modules\\ping\n\n                  VALUENAME \nDriverNameWin16\n \n                  VALUE \nUnsupported\n\n                KEYNAME \nSoftware\\Citrix\\ICA Client\\ Engine\\Configuration\\Advanced\\Modules\\ping\n\n                  VALUENAME \nDriverNameWin32\n \n                  VALUE \nvdpingn.dll\n\n              END ACTIONLISTON \n              ACTIONLISTOFF\n                KEYNAME \nSoftware\\Citrix\\ICA Client\\Engine\\ Configuration\\Advanced\\Modules\\ICA3.0\n\n                  VALUENAME \nVirtualDriverEx\n \n                  VALUE \n\n              END ACTIONLISTOFF\n            END POLICY \n        END CATEGORY\n    END CATEGORY\nEND CATEGORY\n[strings]\n    Citrix=\nCitrix Components\n \n    ICAClient=\nPresentation Server Client\n \n    Third Party=\nExtensions\n\n    Explain_Third Party=\nThese policies control extensions to the standard Citrix Presentation Server Client.\n  Policy_PingVirtualChannel=\nExample Ping Virtual Channel\n \n    Explain_PingVirtualChannel=\n This policy controls the example Ping virtual channel.\\n\\nSupplier:\\n My company.\\n                                \\nReference:Example001\n\n\n\n\n\n\nBest Practices\n\n\nCitrix recommends using the .adm file to customize the following parts of the Group\n\n\nPolicy GUI:\n\n\n\n\nSpecify a name (Additional Virtual Channel in the template file) that describes the functionality provided by the virtual channel.\n\n\nDescription text \n\n\nSupplier\n\n\nReference (for example, add a URL or email address to access further\ninformation). \n\n\nGUI that appears when the policy is double-clicked (optionally and as required).\n\n\n\n\nDo not change the name of the Citrix Components\\Presentation Server\nClient\\Extensions folder.\n\n\nDeploy the virtual channel DLL remotely using existing management tools\nand enable and configure using the above GUI. You can do this to entire\ngroups of computers within an organization.", 
            "title": "Using Example Programs"
        }, 
        {
            "location": "/using-example-programs/#using-example-programs", 
            "text": "The example programs included with the Virtual Channel SDK are\nbuildable, working virtual channels. Use these examples to:   Verify your Virtual Channel SDK is correct by building a known working example program.  Provide working examples of code that can be modified to suit your requirements.  Explore the features and functionality provided in the Virtual Channel SDK.   Each of these example programs comprises a client virtual driver and a\nserver application. The server-side application is run from the command\nline within an ICA session. A single virtual channel comprises an\napplication pair.  The example programs included with the Virtual Channel SDK are:   Ping: Records the round-trip delay time for a test packet sent over a virtual channel.  Mix: Demonstrates a mechanism to call functions (for example, to get the time of day) on a remote client.  Over: Simple asynchronous application that demonstrates how to code an application where the server must receive a response from the client asynchronously, and where the type of packet being sent to the client is different from the type received.   Each example includes a description of the program, packet format, and\nother necessary information.", 
            "title": "Using Example Programs"
        }, 
        {
            "location": "/using-example-programs/#ping", 
            "text": "Ping is a simple program that records the round-trip delay time\nfor a test packet sent over a virtual channel. The server sends a packet to the client and the\nclient responds with a packet containing the time it received the original packet from the\nserver. This sequence is repeated a specified number of times, and then the program displays\nthe round-trip time for each ping and the average round-trip delay time.  For this example, there is no significant difference between a BEGIN\npacket and an END packet. The two types of packets are provided as an example for\nwriting your own virtual channel protocols.  This program demonstrates:   How to transfer data synchronously. The sequence of events is:\n{SrvWrite, ClntRead, ClntWrite, SrvRead} {SrvWrite, ClntRead} {...}.\nThe server waits for the client to reply before sending the next\npacket.  How to read parameter data (in this case, the number of times to send\npackets to the client) from the Module.ini files.", 
            "title": "Ping"
        }, 
        {
            "location": "/using-example-programs/#packet-format", 
            "text": "The following packet is exchanged between the client and the server.  typedef struct  PING  {\nUSHORT          uSign;              // Signature\nUSHORT          uType;              // Type, BEGIN or END, from server\nUSHORT          uLen;               // Packet length from server\nUSHORT          uCounter;           // Sequencer\nULONG           ulServerMS;         // Server millisecond clock\nULONG           ulClientMS;         // Client millisecond clock\n} PING, *PPING;", 
            "title": "Packet Format"
        }, 
        {
            "location": "/using-example-programs/#mix", 
            "text": "Mix demonstrates a mechanism that can be used to call functions on a remote client (for example to get the time of day). This program demonstrates an extensible scheme for making function calls from the server to the client that allows the server to specify when it expects a response from the client and when it does not. This method can increase performance, because the server does not have to constantly wait for a reply from the client.  The server calls a series of simple functions:   Add No: Add two numbers and return the sum as the return value.  Disp Str: Write a string to the log file. There is no return value (write-only function).  Gettime: Read the client time and return it as the return value.   The actual implementation of these functions is on the client side. The server conditionally waits for the response from the client, depending on the function being executed. For example, the server waits for the result of the AddNo or Gettime function, but not the write- only function DispStr, which returns no result.", 
            "title": "Mix"
        }, 
        {
            "location": "/using-example-programs/#packet-format_1", 
            "text": "typedef struct MIXHEAD {                                        \nUSHORT          uType               // Packet type\nUSHORT          uFunc;              // Index of Function\nULONG           uLen;               // Length of data\nUSHORT          fRetReq;            // True if return\nULONG           dwRetVal;           // Return Value from client\nUSHORT          dwLen1;             // length of data\nUSHORT          dwLen2;             // length of data\n}       MIXHEAD, \\*PMIXHEAD;                   The data consists of the above structure followed by the arguments to\nthe function being called. uLen is the total length of the data being\nsent, including the arguments. DwLen1 is the length of the data pointed\nto by a pointer argument.", 
            "title": "Packet Format"
        }, 
        {
            "location": "/using-example-programs/#sequence-of-events", 
            "text": "This figure illustrates the sequence of events that occurs when you use\nthe Mix program, starting at the top.", 
            "title": "Sequence of Events"
        }, 
        {
            "location": "/using-example-programs/#over", 
            "text": "Over is a simple asynchronous application. It demonstrates how to code an application in which the server must receive a response from the client asynchronously, and the type of packet being sent to the client is different from the type received.  When the Over program begins, it:   Spawns a thread that waits for a response from the client.  Begins sending data packets with sequence numbers to the client.  (After sending the last packet of data) sends a packet with a sequence number of NO_MORE_DATA, and then closes the connection.   The client receives packets and inspects the sequence number. For\nevery sequence number divisible by 10, the client increases the\nsequence number by 7 and sends a response to the server. These numbers\nare chosen arbitrarily to demonstrate that the client can\nasynchronously send data to the server at any time.  The packet type used to send data from the server to the client is\ndifferent from the packet type used to receive data from the client.", 
            "title": "Over"
        }, 
        {
            "location": "/using-example-programs/#packet-format-from-server-to-client", 
            "text": "typedef struct OVER  {\n             USHORT         uSign;              // Signature\n             USHORT         uType;              // Type, BEGIN or END, from server\n             USHORT         uLen;               // Packet length from server\n             USHORT         uCounter;           // Sequencer\n             ULONG          ulServerMS;         // Server millisecond clock\n            } OVER, *POVER;", 
            "title": "Packet Format - From Server to Client"
        }, 
        {
            "location": "/using-example-programs/#packet-format-from-client-to-server", 
            "text": "typedef struct DRVRESP  {\n             USHORT         uType;              // Type OVERFLOW_JUMP from client\n             USHORT         uLen;               // Packet length from client\n             USHORT         uCounter;           // Sequencer\n            } DRVRESP, *PDRVRESP;", 
            "title": "Packet Format - From Client to Server"
        }, 
        {
            "location": "/using-example-programs/#sequence-of-events_1", 
            "text": "This figure illustrates the sequence of events that occurs when you\nuse the Over program, starting at the top.", 
            "title": "Sequence of Events"
        }, 
        {
            "location": "/using-example-programs/#building-examples", 
            "text": "", 
            "title": "Building Examples"
        }, 
        {
            "location": "/using-example-programs/#building-a-server-side-example-using-nmake", 
            "text": "Change to the vcsdk\\src\\examples\\vc\\server\\ subdirectory.    At a command prompt, type  NMAKE clean all .    To build an individual server example, run NMAKE from the example subdirectory.", 
            "title": "Building a Server- side Example using NMAKE"
        }, 
        {
            "location": "/using-example-programs/#building-a-server-side-example-using-visual-studio-or-net", 
            "text": "Create a new Win32 console project. Citrix recommends that the\n    project name be associated with the example (for\n    example, ctxping). You can set the location of the project to the\n    src\\examples\\vc\\server directory so that the .c source files\n    are readily available.    Add the following directories to include the search path of the C++\n    preprocessor in the project settings (where vcsdk is the directory\n    for the Virtual Channel SDK):   vcsdk\\src\\examples\\vc\\shared\\inc  vcsdk\\src\\shared\\inc\\Citrix     Point to the wfapi include and library paths. Open file wfapi.mak\n    from vcsdk installation path\\src\\examples\\build.   Set WFAPILIB to the full path of WFAPI lib directory.  Set WFAPIINC to the full path of WFAPI include directory.      The WFAPI SDK installs Wfapi.lib into the designated library directory.", 
            "title": "Building a Server- side Example using Visual Studio or .NET"
        }, 
        {
            "location": "/using-example-programs/#building-a-client-side-example-for-win-32-using-nmake", 
            "text": "Browse to the Visual Studios Common tools folder and run  vsvars32.bat .    Open user.mak in the  \\src\\examples\\build directory.   Set the paths corresponding to your installation of Visual Studio  Set the paths corresponding to your installation of the Windows SDK.  Set the paths corresponding to your installation of WFAPI.     Open wfapi.mak in the  \\src\\examples\\build directory. Set the paths\n    corresponding to your installation of WFAPI.    Change to directory  \\src\\examples\\vc.    For each example you want to build, type    cd client\\example  nmake win32.cln     To build the retail modules, type  nmake win32    To build the debug modules, type  nmake win32.dbg", 
            "title": "Building a Client- side Example for Win 32 using NMAKE"
        }, 
        {
            "location": "/using-example-programs/#building-a-client-side-example-for-win-32-using-visual-studio", 
            "text": "For all platforms, the virtual channel driver DLL must export the\n    Load function. You can do this with either a .DEF file or by\n    specifying it as a compiler option in your Visual Studio\n    project setting.    Make sure the calling convention is set to stdcall.", 
            "title": "Building a Client-side Example for Win 32 using Visual Studio"
        }, 
        {
            "location": "/using-example-programs/#preparing-and-deploying-a-virtual-driver", 
            "text": "Before installing a virtual driver on a client, copy the virtual\ndriver for the platform to the client device and configure the client\nMSI.    Copy the appropriate virtual driver for the platform to the\n    directory on the device where the client is installed. The virtual\n    driver is the .Dll file in\n     \\src\\examples\\vc\\client\\driver\\platform\\obj\\retail , where\n    driver is  vdmix ,  vdover , or  vdping . The default installation\n    directory is  %SystemDrive%\\Program Files\\Citrix\\ICA Client .    Open the standard client MSI package with the Microsoft packaging\n    tools (for example, Orca in the Windows Installer SDK).    Add the virtual channel .DLL to the MSI package.    Modify the Configuration Storage file  /configuration/module.ini .     Warning Editing the Registry incorrectly can cause serious problems\nthat may require you to reinstall your operating system. Citrix cannot\nguarantee that problems resulting from the incorrect use of Registry\nEditor can be solved. Use the Registry Editor at your own risk. Be\nsure to back up the registry before you edit it.     Locate the VirtualDriverEx string REG_SZ value in the HKEY_LOCAL_MACHINE\\SOFTWARE\\Citrix\\ICAClient\\Engine\\Configuration\\Advanced\\Modules\\ICA3.0 key. Append the name of the virtual driver to the end of this line, for example:  VirtualDriverEx = VDPING .  Under the  HKEY_LOCAL_MACHINE\\SOFTWARE\\Citrix\\ICAClient\\Engine\\Configuration\\Advanced\\Modules  key, create a new   key, where  ; is VDMIX, VDOVER, VDPING. For VDPING, the section would be:  HKEY_LOCAL_MACHINE\\SOFTWARE\\Citrix\\ICAClient\\Engine\\Configuration\\Advanced\\Modules\\ VDPING . Add the following string REG_SZ values under the above key:   DriverName          = VDPING.DLL\nDriverNameWin16     = VDPINGW.DLL\nDriverNameWin32     = VDPINGN.DLL\nPingCount           = 3  The client engine uses DriverName, DriverNameWin16, and\nDriverNameWin32 to determine the module filename to load for each\nplatform. PingCount is a tunable parameter used by the Ping virtual\nchannel.  . Repackage the MSI for deployment.", 
            "title": "Preparing and Deploying a Virtual Driver"
        }, 
        {
            "location": "/using-example-programs/#to-deploy-the-msi", 
            "text": "Deploy your MSI package with Windows Active Directory Services or\nMicrosoft Systems Management Server. See your Windows or Systems\nManagement Server documentation for more information. No further\nconfiguration is necessary.", 
            "title": "To deploy the MSI"
        }, 
        {
            "location": "/using-example-programs/#to-add-a-virtual-channel-after-installation", 
            "text": "Because the Module.ini file is installed in the registry, modifying\nthe file after installation has no effect. To add a virtual channel\nafter installation, use the Group Policy template or change the\nregistry keys corresponding to those in the Module.ini file at the\nfollowing registry location:  HKEY_LOCAL_MACHINE\\SOFTWARE\\Citrix\\ICAClient\\Engine\\Configuration\\Advanced\\Modules", 
            "title": "To add a virtual channel after installation"
        }, 
        {
            "location": "/using-example-programs/#running-an-example-virtual-channel", 
            "text": "On a client configured with the client-side example, connect to a\n    server running XenApp/XenDesktop with the associated\n    server-side example.    Within the ICA session, run the server-side executable.    The server-side example queries the client-side virtual driver, and\nthen displays the driver information. Use the -d parameter to display detailed information.  For Ping only: CTXPING sends PingCount separate pings. PingCount has a\ndefault value of three, but can be set in the [Ping] section of the\nModule.ini file. Each ping consists of a BEGIN packet and an END\npacket.", 
            "title": "Running an Example Virtual Channel"
        }, 
        {
            "location": "/using-example-programs/#debugging-a-win32-virtual-driver", 
            "text": "Use the TRACE feature to log events on the client. To enable the TRACE\nstatements, you must build the debug version of the virtual driver. When\nthe debug module is installed on the client, the TRACE statements write\nthe debug information to a file.  At run time, you can specify which class and event flags to trace. This\nallows you to trace only the sections you need, minimizing performance\ndegradation.  The class flag for virtual channels is 00000080. For the complete list\nof class and event flags, see Logflags.h (in src\\inc).    Compile the debug version of the virtual driver for the\n    client platform.    If it is running, close the client on the client device.    Copy the compiled debug version of the library into the directory on\n    the client device where the client is installed. For example, for\n    the Ping example, copy VdpingN.dll to \\Citrix\\ICA Client.    Change to the directory containing the client and type:    wfcrun32 connection /c:xxxxxxxx /e:yyyyyyyy /logfile:filename   where:  connection is the name of the connection in Remote Application\nManager.  xxxxxxxx are the event flags you want to log.  yyyyyyyy are the class flags you want to log.  filename is the relative path of the file to which you want to save\nthe log.  The client stores the Appsrv.ini file in each user\u2019s profile directory.\nWhen starting the ICA session with event logging, add /iniappsrv:%userprofile%\\\u201dapplication data\u201d\\icaclient\\appsrv.ini  to\nthe end of the command line above.", 
            "title": "Debugging a Win32 virtual driver"
        }, 
        {
            "location": "/using-example-programs/#deploying-client-virtual-channels-remotely", 
            "text": "To deploy virtual channels remotely, make changes based on the following\nadministrative template (.adm) file.  CustomVC is a placeholder for the channel name of the virtual channel.  ;Group Policy template for Citrix Windows Receiver.\n;Citrix Windows Receiver Client Extensions template\n;Description:\n;This file is provided as a base for third-party extensions\n;to the Citrix Windows Receiver client.\n; Copyright (C) Citrix Systems, Inc. All Rights Reserved.\n;\nCLASS MACHINE\nCATEGORY !!Citrix \n    CATEGORY !!ICAClient\n        CATEGORY !!Third Party\n          #if version  = 4\n          EXPLAIN !!Explain_Third Party\n          #endif\n          ; Remotely define virtual channel \n          POLICY !!Policy_CustomVirtualChannel\n            EXPLAIN !!Explain_CustomVirtualChannel\n            KEYNAME  Software\\Policies\\Citrix\\ICA Client\\Engine\\Lockdown \n            Profiles\\All Regions\\Lockdown\\Virtual Channels\\Third \n            Party\\CustomVC \n            VALUENAME  VCEnable \n            VALUEON  true,false  VALUEOFF  false  ACTIONLISTON \n            KEYNAME  Software\\Citrix\\ICA Client\\Engine\\Lockdown \n            Profiles\\All Regions\\Lockdown\\Virtual Channels\\Third \n            Party\\CustomVC \n                    VALUENAME  VCEnable  \n                    VALUE     \n                    KEYNAME  Software\\Citrix\\ICA \n            Client\\Engine\\Configuration\\Advanced\\Modules\\ICA 3.0 \n                    VALUENAME  VirtualDriverEx  \n                    VALUE  CustomVC \n                    KEYNAME  Software\\Citrix\\ICA            Client\\Engine\\Configuration\\Advanced\\Modules\\CustomVC \n                    VALUENAME  DriverName  \n                    VALUE  Unsupported  \n                    KEYNAME  Software\\Citrix\\ICA\n            Client\\Engine\\Configuration\\Advanced\\Modules\\CustomVC  \n                    VALUENAME  DriverNameWin16 \n                    VALUE  Unsupported  \n                    KEYNAME  Software\\Citrix\\ICA\n            Client\\Engine\\Configuration\\Advanced\\Modules\\CustomVC  \n                    VALUENAME  DriverNameWin32  \n                    VALUE  VDCustomVC.DLL \n                END ACTIONLISTON \n                ACTIONLISTOFF\n                    KEYNAME  Software\\Citrix\\ICA \n            Client\\Engine\\Configuration\\Advanced\\Modules\\ICA 3.0 \n                    VALUENAME  VirtualDriverEx  \n                    VALUE  \n                    END ACTIONLISTOFF\n            END POLICY \n        END CATEGORY\n    END CATEGORY \nEND CATEGORY\n[strings]\nCitrix= Citrix Components  \nICAClient= Presentation Server Client  \nThird Party= Extensions \nExplain_Third Party= These policies control extensions to the standard Citrix Presentation Server Client. \nPolicy_CustomVirtualChannel= Additional Virtual Channel \nExplain_CustomVirtualChannel=  This policy controls a virtual\nchannel.\\n\\nSupplier:\\nMy\ncompany.\\n\\nReference:", 
            "title": "Deploying Client Virtual Channels Remotely"
        }, 
        {
            "location": "/using-example-programs/#administrative-template-changes-for-ping-example", 
            "text": "For the ping virtual channel example, edit the .adm template file as\nfollows (changes in the text are in boldface).   Note The Memory INI functions require the lines in the example\nreferencing VCEnable. Every parameter used by the virtual channel must\nappear in this file. The client uses these to place security\nrestrictions on the virtual channels.    ;\n;   Group policy template for Citrix Windows Recevier Client\n;   Ping virtual channel example template\n;   Description;\n;   A Group Policy template to remotely configure the Ping Virtual Channel\nCLASS MACHINE\nCATEGORY !! Citrix\n    CATEGORY !! ICAClient\n        CATEGORY !!Third Party\n            #if version  =4\n              EXPLAIN !!Explain_Thrid Party\n            #endif\n            ;\n            ;   Remotely configure the Ping Virtual Channel\n            ;\n            POLICY !!Policy_PingVirtualChannel\n              EXPLAIN !!Explain_PingVirtualChannel\n              KEYNAME  Software\\Policies\\Citrix\\ICA Client\\Engine\\Lockdown \n              Profiles\\All Regions\\Lockdown\\Virtual Channels\\Third Party\\ping \n                VALUENAME  VCEnable \n                VALUEON true,false \n                VALUEOFF false \n              ACTIONLISTON\n                KEYNAME Software\\Citrix\\ICA Client\\Engine\\Lockdown\\\n                Profiles\\All Regions\\Lockdown\\Virtual Channels\\Third\n                Party\\ping \n                  VALUENAME  VCEnable \n                  VALUE  \n                KEYNAME Software\\Citrix\\ICA Client\\Engine\\Configuration\\Advanced\\Module\\ICA 3.0 \n                  VALUENAME  VirtualDriverEx \n                  VALUE  ping \n                KEYNAME Software\\Citrix\\ICA Client\\Engine\\Configuration\\Advanced\\Modules\\ping \n                  VALUENAME  DriverName \n                  VALUE  Unsupported    \n                KEYNAME  Software\\Citrix\\ICA Client\\Engine\\Configuration\\ Advanced\\Modules\\ping \n                  VALUENAME  DriverNameWin16  \n                  VALUE  Unsupported \n                KEYNAME  Software\\Citrix\\ICA Client\\ Engine\\Configuration\\Advanced\\Modules\\ping \n                  VALUENAME  DriverNameWin32  \n                  VALUE  vdpingn.dll \n              END ACTIONLISTON \n              ACTIONLISTOFF\n                KEYNAME  Software\\Citrix\\ICA Client\\Engine\\ Configuration\\Advanced\\Modules\\ICA3.0 \n                  VALUENAME  VirtualDriverEx  \n                  VALUE  \n              END ACTIONLISTOFF\n            END POLICY \n        END CATEGORY\n    END CATEGORY\nEND CATEGORY\n[strings]\n    Citrix= Citrix Components  \n    ICAClient= Presentation Server Client  \n    Third Party= Extensions \n    Explain_Third Party= These policies control extensions to the standard Citrix Presentation Server Client.   Policy_PingVirtualChannel= Example Ping Virtual Channel  \n    Explain_PingVirtualChannel=  This policy controls the example Ping virtual channel.\\n\\nSupplier:\\n My company.\\n                                \\nReference:Example001", 
            "title": "Administrative Template Changes for Ping Example"
        }, 
        {
            "location": "/using-example-programs/#best-practices", 
            "text": "Citrix recommends using the .adm file to customize the following parts of the Group  Policy GUI:   Specify a name (Additional Virtual Channel in the template file) that describes the functionality provided by the virtual channel.  Description text   Supplier  Reference (for example, add a URL or email address to access further\ninformation).   GUI that appears when the policy is double-clicked (optionally and as required).   Do not change the name of the Citrix Components\\Presentation Server\nClient\\Extensions folder.  Deploy the virtual channel DLL remotely using existing management tools\nand enable and configure using the above GUI. You can do this to entire\ngroups of computers within an organization.", 
            "title": "Best Practices"
        }, 
        {
            "location": "/programming-guide/", 
            "text": "Programming Guide\n\n\nVirtual channels are referred to by a seven-character (or shorter) ASCII\nname. In several previous versions of the ICA protocol, virtual channels\nwere numbered; the numbers are now assigned dynamically based on the\nASCII name, making implementation easier.\n\n\nWhen developing virtual channel code for internal use only, you can use\nany seven-character name that does not conflict with existing virtual\nchannels. Use only upper and lowercase ASCII letters and numbers. Follow\nthe existing naming convention when adding your own virtual channels.\n\n\nThe predefined channels, which begin with the OEM identifier CTX, are\nfor use only by Citrix.\n\n\nDesign Suggestions\n\n\nFollow these suggestions to make your virtual channels easier to design\nand enhance:\n\n\n\n\nWhen you design your own virtual\nchannel protocol, allow for the flexibility to add features. Virtual\nchannels have version numbers that are exchanged during initialization\nso that both the client and the server detect the maximum level of\nfunctionality that can be used. For example, if the client is at\nVersion 3 and the server is at Version 5, the server does not send any\npackets with functionality beyond Version 3 because the client does\nnot know how to interpret the newer packets.\n\n\nBecause the server side of a virtual\nchannel protocol can be implemented as a separate process, it is\neasier to write code that interfaces with the Citrix-provided virtual\nchannel support on the server than on the client (where the code must\nfit into an existing code structure). The server side of a virtual\nchannel simply opens the channel, reads from and writes to it, and\ncloses it when done.\nWriting code for the server-side is similar to writing an application,\nwhich uses services exported by the system. It is easier to write an\napplication to handle the virtual channel communication because it can\nthen be run once for each ICA connection supporting the virtual\nchannel.\nWriting for the client-side is similar to writing a driver, which must\nprovide services to the system in addition to using system services.\nIf a service is written, it must manage multiple connections.\n\n\nIf you are designing new hardware for\nuse with new virtual channels (for example, an improved compressed\nvideo format), make sure the hardware can be detected so that the\nclient can determine whether or not it is installed. Then the client\ncan communicate to the server if the hardware is available before the\nserver uses the new data format. Optionally, you could have the\nvirtual driver translate the new data format for use with older\nhardware.\n\n\nThere might be limitations preventing\nyour new virtual channel from performing at an optimum level. If the\nclient is connecting to the server running XenApp through a modem or\nserial connection, the bandwidth might not be great enough to properly\nsupport audio or video data. You can make your protocol adaptive, so\nthat as bandwidth decreases, performance degrades gracefully, possibly\nby sending sound normally but reducing the frame rate of the video to\nfit the available bandwidth.\n\n\nTo identify where problems are\noccurring (connection, implementation, or protocol), first get the\nconnection and communication working. Then, after the virtual channel\nis complete and debugged, do some time trials and record the results.\nThese results establish a baseline for measuring further optimizations\nsuch as compression and other enhancements so that the channel\nrequires less bandwidth.\n\n\nThe time stamp in the pVdPoll variable\ncan be helpful for resolving timing issues in your virtual driver. It\nis a ULONG containing the current time in milliseconds. The pVdPoll\nvariable is a pointer to a DLLPOLL structure. See Dllapi.h (in\nsrc/inc/) for definitions of these structures.\n\n\n\n\nServer-Side Functions Overview\n\n\nServer-side functions are entry points to virtual channel services\nprovided by the ICAsubsystem on the XenApp or XenDesktop server. Wfapi.h\ncontains constants and function prototypes.\n\n\nUse these functions to open and close virtual channels and to read,\nwrite, query, and purge incoming or outgoing data.\n\n\nThe words IN and OUT in the function calling conventions are for\nclarification only. They are defined as blank in Windef.h. If you do not\nhave access to Windef.h, add the following to a header file for your\nproject:\n\n\n#ifndef IN\n\n\n#define IN\n\n\n#endif\n\n\n#ifndef OUT\n\n\n#endif\n\n\n\n\n\n\n\n\n\n\n\n\nFunction\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nWFVirtualChannelClose\n\n\nCloses an open virtual channel handle.\n\n\n\n\n\n\nWFVirtualChannelOpen\n\n\nOpens a handle to a specific virtual channel.\n\n\n\n\n\n\nWFVirtualChannelPurgeInput\n\n\nPurges all queued input data sent from the client to the server on a specific virtual channel.\n\n\n\n\n\n\nWFVirtualChannelPurgeOutput\n\n\nPurges all queued output data sent from the server to the client on a specific virtual channel.\n\n\n\n\n\n\nWFVirtualChannelQuery\n\n\nReturns data related to a virtual channel.\n\n\n\n\n\n\nWFVirtualChannelRead\n\n\nReads data from a virtual channel.\n\n\n\n\n\n\nWFVirtualChannelWrite\n\n\nWrites data to a virtual channel.\n\n\n\n\n\n\n\n\nClient-Side Functions Overview\n\n\nThe client software is built on a modular configurable architecture that\nallows replaceable, configurable modules (such as virtual channel\ndrivers) to handle various aspects of an ICA connection. These modules\nare specially formatted and dynamically loadable. To accomplish this\nmodular capability, each module (including virtual channel drivers)\nimplements a fixed set of function entry points.\n\n\nThere are three groups of functions: user-defined, virtual driver\nhelper, and memory INI.\n\n\nUser-defined Functions\n\n\nTo make writing virtual channels easier, dynamic loading is handled by\nthe WinStation driver, which in turn calls user-defined functions. This\nsimplifies creating the virtual channel because all you have to do is\nfill in the functions and link your virtual channel driver with\nVdapi.lib (provided with this SDK).\n\n\n\n\n\n\n\n\nFunction\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDriverClose\n\n\nFrees private driver data. Called before unloading a virtual driver (generally upon client exit).\n\n\n\n\n\n\nDriverGetLastError\n\n\nReturns the last error set by the virtual driver. Not used; links with the common front end, VDAPI.\n\n\n\n\n\n\nDriverInfo\n\n\nRetrieves information about the virtual driver.\n\n\n\n\n\n\nDriverOpen\n\n\nPerforms all initialization for the virtual driver. Called once when the client loads the virtual driver (at startup).\n\n\n\n\n\n\nDriverPoll\n\n\nAllows driver to check timers and other state information, sends queued data to the server, and performs any other required processing. Called periodically to see if the virtual driver has any data to write.\n\n\n\n\n\n\nDriverQueryInformation\n\n\nRetrieves run-time information from the virtual driver.\n\n\n\n\n\n\nDriverSetInformation\n\n\nSets run-time information in the virtual driver.\n\n\n\n\n\n\nICADataArrival\n\n\nIndicates that data was delivered. Called when data arrives on the virtual channel.\n\n\n\n\n\n\n\n\nVirtual Driver Helper Functions\n\n\nThe virtual driver uses helper functions to send data and manage the\nvirtual channel. When the WinStation driver initializes the virtual\ndriver, the WinStation driver passes pointers to the helper functions\nand the virtual driver passes pointers to the user-defined functions.\n\n\nVdCallWd is linked in as part of VDAPI and is available in all\nuser-implemented functions. The others are obtained during DriverOpen\nwhen VdCallWd is called with the WDxSETINFORMATION parameter.\n\n\nVirtual channel drivers can send data from private buffers via the\nSendData or QueueVirtualWrite functions obtained during DriverOpen.\nEither of these functions may decline to accept the data if the\nWinSation Driver itself cannot buffer it. The channel will then need to\nretry the send operation on the next DriverPoll.\n\n\n\n\n\n\n\n\nFunction\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSendData\n\n\nTo send a packet of channel protocol to the server, with a notification option.\n\n\n\n\n\n\nQueueVirtualWrite\n\n\nTo send a packet of channel protocol to the server. This is a legacy function. Use SendData above for new virtual drivers.\n\n\n\n\n\n\nVdCallWd\n\n\nUsed to query and set information from the WinStation driver (WD).\n\n\n\n\n\n\n\n\nMemory INI Functions\n\n\nMemory INI functions read data that the client engine reads from the\nConfiguration Storage in the registry and stored in a memory INI\nstructure. These functions must be used because some client devices\nstore this information in ROM, and only the engine has access to this\nINI data. The Memory INI functions read values from this Memory INI\nstructure as if the values are being read from the Configuration\nStorage. The Configuration Storage for specifying virtual channels is in\nSoftware\\Citrix\\ICA Client\\Configuration\\Advanced\\Modules.\n\n\nImportant: Access to configuration data might be limited depending on\nsecurity restrictions . In particular, the virtual channel might not\nhave access to all contents of the ICA file. This is controlled by\nregistry keys in HKEY_LOCAL_MACHINE\\SOFTWARE\\Citrix\\ICA\nClient\\Engine\\Lock down Profiles\\All Regions\\Lock down. You can use\nMemory INI functions read data from the client engine configuration\nfiles stored in both the client installation directory for system wide\nsettings and $HOME/.ICAClient for user specific settings.\n\n\nFor each entry in appsrv.ini and wfclient.ini, there must be a\ncorresponding entry in All_Regions.ini for the setting to take effect.\nFor more information, refer to All_Regions.ini file in the\n$ICAROOT/config directory.\n\n\n\n\n\n\n\n\nFunction\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmiGetPrivateProfileBool\n\n\nReturns a boolean value.\n\n\n\n\n\n\nmiGetPrivateProfileInt\n\n\nReturns an integer value.\n\n\n\n\n\n\nmiGetPrivateProfileLong\n\n\nReturns a long value.\n\n\n\n\n\n\nmiGetPrivateProfileString\n\n\nReturns a string value.", 
            "title": "Programming Guide"
        }, 
        {
            "location": "/programming-guide/#programming-guide", 
            "text": "Virtual channels are referred to by a seven-character (or shorter) ASCII\nname. In several previous versions of the ICA protocol, virtual channels\nwere numbered; the numbers are now assigned dynamically based on the\nASCII name, making implementation easier.  When developing virtual channel code for internal use only, you can use\nany seven-character name that does not conflict with existing virtual\nchannels. Use only upper and lowercase ASCII letters and numbers. Follow\nthe existing naming convention when adding your own virtual channels.  The predefined channels, which begin with the OEM identifier CTX, are\nfor use only by Citrix.", 
            "title": "Programming Guide"
        }, 
        {
            "location": "/programming-guide/#design-suggestions", 
            "text": "Follow these suggestions to make your virtual channels easier to design\nand enhance:   When you design your own virtual\nchannel protocol, allow for the flexibility to add features. Virtual\nchannels have version numbers that are exchanged during initialization\nso that both the client and the server detect the maximum level of\nfunctionality that can be used. For example, if the client is at\nVersion 3 and the server is at Version 5, the server does not send any\npackets with functionality beyond Version 3 because the client does\nnot know how to interpret the newer packets.  Because the server side of a virtual\nchannel protocol can be implemented as a separate process, it is\neasier to write code that interfaces with the Citrix-provided virtual\nchannel support on the server than on the client (where the code must\nfit into an existing code structure). The server side of a virtual\nchannel simply opens the channel, reads from and writes to it, and\ncloses it when done.\nWriting code for the server-side is similar to writing an application,\nwhich uses services exported by the system. It is easier to write an\napplication to handle the virtual channel communication because it can\nthen be run once for each ICA connection supporting the virtual\nchannel.\nWriting for the client-side is similar to writing a driver, which must\nprovide services to the system in addition to using system services.\nIf a service is written, it must manage multiple connections.  If you are designing new hardware for\nuse with new virtual channels (for example, an improved compressed\nvideo format), make sure the hardware can be detected so that the\nclient can determine whether or not it is installed. Then the client\ncan communicate to the server if the hardware is available before the\nserver uses the new data format. Optionally, you could have the\nvirtual driver translate the new data format for use with older\nhardware.  There might be limitations preventing\nyour new virtual channel from performing at an optimum level. If the\nclient is connecting to the server running XenApp through a modem or\nserial connection, the bandwidth might not be great enough to properly\nsupport audio or video data. You can make your protocol adaptive, so\nthat as bandwidth decreases, performance degrades gracefully, possibly\nby sending sound normally but reducing the frame rate of the video to\nfit the available bandwidth.  To identify where problems are\noccurring (connection, implementation, or protocol), first get the\nconnection and communication working. Then, after the virtual channel\nis complete and debugged, do some time trials and record the results.\nThese results establish a baseline for measuring further optimizations\nsuch as compression and other enhancements so that the channel\nrequires less bandwidth.  The time stamp in the pVdPoll variable\ncan be helpful for resolving timing issues in your virtual driver. It\nis a ULONG containing the current time in milliseconds. The pVdPoll\nvariable is a pointer to a DLLPOLL structure. See Dllapi.h (in\nsrc/inc/) for definitions of these structures.", 
            "title": "Design Suggestions"
        }, 
        {
            "location": "/programming-guide/#server-side-functions-overview", 
            "text": "Server-side functions are entry points to virtual channel services\nprovided by the ICAsubsystem on the XenApp or XenDesktop server. Wfapi.h\ncontains constants and function prototypes.  Use these functions to open and close virtual channels and to read,\nwrite, query, and purge incoming or outgoing data.  The words IN and OUT in the function calling conventions are for\nclarification only. They are defined as blank in Windef.h. If you do not\nhave access to Windef.h, add the following to a header file for your\nproject:  #ifndef IN  #define IN  #endif  #ifndef OUT  #endif      Function  Description      WFVirtualChannelClose  Closes an open virtual channel handle.    WFVirtualChannelOpen  Opens a handle to a specific virtual channel.    WFVirtualChannelPurgeInput  Purges all queued input data sent from the client to the server on a specific virtual channel.    WFVirtualChannelPurgeOutput  Purges all queued output data sent from the server to the client on a specific virtual channel.    WFVirtualChannelQuery  Returns data related to a virtual channel.    WFVirtualChannelRead  Reads data from a virtual channel.    WFVirtualChannelWrite  Writes data to a virtual channel.", 
            "title": "Server-Side Functions Overview"
        }, 
        {
            "location": "/programming-guide/#client-side-functions-overview", 
            "text": "The client software is built on a modular configurable architecture that\nallows replaceable, configurable modules (such as virtual channel\ndrivers) to handle various aspects of an ICA connection. These modules\nare specially formatted and dynamically loadable. To accomplish this\nmodular capability, each module (including virtual channel drivers)\nimplements a fixed set of function entry points.  There are three groups of functions: user-defined, virtual driver\nhelper, and memory INI.", 
            "title": "Client-Side Functions Overview"
        }, 
        {
            "location": "/programming-guide/#user-defined-functions", 
            "text": "To make writing virtual channels easier, dynamic loading is handled by\nthe WinStation driver, which in turn calls user-defined functions. This\nsimplifies creating the virtual channel because all you have to do is\nfill in the functions and link your virtual channel driver with\nVdapi.lib (provided with this SDK).     Function  Description      DriverClose  Frees private driver data. Called before unloading a virtual driver (generally upon client exit).    DriverGetLastError  Returns the last error set by the virtual driver. Not used; links with the common front end, VDAPI.    DriverInfo  Retrieves information about the virtual driver.    DriverOpen  Performs all initialization for the virtual driver. Called once when the client loads the virtual driver (at startup).    DriverPoll  Allows driver to check timers and other state information, sends queued data to the server, and performs any other required processing. Called periodically to see if the virtual driver has any data to write.    DriverQueryInformation  Retrieves run-time information from the virtual driver.    DriverSetInformation  Sets run-time information in the virtual driver.    ICADataArrival  Indicates that data was delivered. Called when data arrives on the virtual channel.", 
            "title": "User-defined Functions"
        }, 
        {
            "location": "/programming-guide/#virtual-driver-helper-functions", 
            "text": "The virtual driver uses helper functions to send data and manage the\nvirtual channel. When the WinStation driver initializes the virtual\ndriver, the WinStation driver passes pointers to the helper functions\nand the virtual driver passes pointers to the user-defined functions.  VdCallWd is linked in as part of VDAPI and is available in all\nuser-implemented functions. The others are obtained during DriverOpen\nwhen VdCallWd is called with the WDxSETINFORMATION parameter.  Virtual channel drivers can send data from private buffers via the\nSendData or QueueVirtualWrite functions obtained during DriverOpen.\nEither of these functions may decline to accept the data if the\nWinSation Driver itself cannot buffer it. The channel will then need to\nretry the send operation on the next DriverPoll.     Function  Description      SendData  To send a packet of channel protocol to the server, with a notification option.    QueueVirtualWrite  To send a packet of channel protocol to the server. This is a legacy function. Use SendData above for new virtual drivers.    VdCallWd  Used to query and set information from the WinStation driver (WD).", 
            "title": "Virtual Driver Helper Functions"
        }, 
        {
            "location": "/programming-guide/#memory-ini-functions", 
            "text": "Memory INI functions read data that the client engine reads from the\nConfiguration Storage in the registry and stored in a memory INI\nstructure. These functions must be used because some client devices\nstore this information in ROM, and only the engine has access to this\nINI data. The Memory INI functions read values from this Memory INI\nstructure as if the values are being read from the Configuration\nStorage. The Configuration Storage for specifying virtual channels is in\nSoftware\\Citrix\\ICA Client\\Configuration\\Advanced\\Modules.  Important: Access to configuration data might be limited depending on\nsecurity restrictions . In particular, the virtual channel might not\nhave access to all contents of the ICA file. This is controlled by\nregistry keys in HKEY_LOCAL_MACHINE\\SOFTWARE\\Citrix\\ICA\nClient\\Engine\\Lock down Profiles\\All Regions\\Lock down. You can use\nMemory INI functions read data from the client engine configuration\nfiles stored in both the client installation directory for system wide\nsettings and $HOME/.ICAClient for user specific settings.  For each entry in appsrv.ini and wfclient.ini, there must be a\ncorresponding entry in All_Regions.ini for the setting to take effect.\nFor more information, refer to All_Regions.ini file in the\n$ICAROOT/config directory.     Function  Description      miGetPrivateProfileBool  Returns a boolean value.    miGetPrivateProfileInt  Returns an integer value.    miGetPrivateProfileLong  Returns a long value.    miGetPrivateProfileString  Returns a string value.", 
            "title": "Memory INI Functions"
        }, 
        {
            "location": "/programming-reference/", 
            "text": "Programming Reference\n\n\nFor function summaries , see:\n\n\n\n\nServer-Side Functions Overview\n\n\nClient-Side Functions Overview\n\n\n\n\nDriverClose\n\n\nThe WinStation driver calls this function prior to unloading the\nvirtual driver, when the ICA connection is being terminated.\n\n\nCalling Convention\n\n\nINT Driverclose\n    ( PVD pVD,\n    PDLLCLOSE pVdClose, \n    PUINT16 puiSize);\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npVD\n\n\nPointer to a virtual driver control structure.\n\n\n\n\n\n\npVdClose\n\n\nPointer to a standard driver close information structure.\n\n\n\n\n\n\npuiSize\n\n\nPointer to the size of the driver close information structure. This is an input parameter.\n\n\n\n\n\n\n\n\nReturn Values\n\n\nIf the function succeeds the return value is CLIENT_STATUS_SUCCESS.\n\n\nIf the function fails, the return value is the CLIENT_ERROR_* value\ncorresponding to the error condition; see clterr.h (in src/inc/) for a\nlist of error values beginning with CLIENT_ERROR.\n\n\nRemarks\n\n\nWhen DriverClose is called, all private driver data is freed. The\nvirtual driver does not need to deallocate the virtual channel or write\nhooks.\n\n\nThe pVdClose structure currently contains one element \u2013 NotUsed. This\nstructure can be ignored.\n\n\nDriverGetLastError\n\n\nThis function is not used but is available for linking with the common\nfront end, VDAPI. \n\n\nCalling Convention\n\n\nINT DriverGetLastError(\nPVD pVD,\nPVDLASSTERROR pVdLastError);\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npVD\n\n\nPointer to a virtual driver control structure.\n\n\n\n\n\n\npVdLast Error\n\n\nPointer to a structure that receives the last error information.\n\n\n\n\n\n\n\n\nReturn Value\n\n\nThe driver returns CLIENT_STATUS_SUCCESS. \n\n\nRemarks\n\n\nThis function currently has no practical significance for virtual\ndrivers; it is provided for compatibility with the loadable module\ninterface.\n\n\nDriverInfo\n\n\nGets information about the virtual driver, such as the version level of\nthe driver.\n\n\nCalling Convention\n\n\nINT DriverInfo(\nPVD pVD,\nPDLLINFO pVdInfo,\nPUINT16 puiSize);\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npVD\n\n\nPointer to a virtual driver control structure.\n\n\n\n\n\n\npVdInfo\n\n\nPointer to a standard driver information structure.\n\n\n\n\n\n\npuiSize\n\n\nPointer to the size of the driver information structure. This is an output parameter.\n\n\n\n\n\n\n\n\nReturn Value\n\n\nIf the function succeeds, it returns CLIENT_STATUS_SUCCESS.\n\n\nIf the function fails because the buffer pointed to by pVdInfo is too\nsmall, it returns CLIENT_ERROR_BUFFER_TOO_SMALL. Normally, when a\nCLIENT_ERROR_ result code is returned, the ICA session is\ndisconnected. CLIENT_ERROR_BUFFER_ TOO_SMALL is an exception and\ndoes not result in the ICA session being disconnected. Instead, the\nWinStation driver attempts to call DriverInfo again with the ByteCount\nof pVdInfo returned by the failed call.\n\n\nRemarks\n\n\nWhen the client starts, it calls this function to retrieve\nmodule-specific information for transmission to the host. This\ninformation is returned to the server side of the virtual channel by\nWFVirtualChannelQuery.\n\n\nThe virtual driver must support this call by returning a structure in\nthe pVdInfo buffer. This structure can be a developer-defined virtual\nchannel-specific structure, but it must begin with a VD_C2H structure,\nwhich in turn begins with a MODULE_C2H structure. All fields of the\nVD_C2H structure must be filled in except for the ChannelMask field.\nSee ica-c2h.h (in src/inc/) for definitions of these structures.\n\n\nThe virtual driver must first check the size of the information buffer\ngiven against the size that the virtual driver requires (the VD_C2H\nstructure). The size of the input buffer is given in pVdInfo\n-\nByteCount.\n\n\nIf the buffer is too small to store the information that the driver\nneeds to send, the correct size is filled into the ByteCount field and\nthe driver returns CLIENT_ERROR_BUFFER_TOO_SMALL.\n\n\nIf the buffer is large enough, the driver must fill it with a\nmodule-defined structure. At a minimum, this structure must contain a\nVD_C2H structure. The VD_C2H structure must be the first data in the\nbuffer; additional channel-specific data can follow. All relevant fields\nof this structure are filled in by this function. The flow control\nmethod is specified in the VDFLOW structure (an element of the VD_C2H\nstructure). The Ping example contains a flow control selection.\n\n\nThe WinStation driver calls this function twice at initialization, after\ncalling DriverOpen. The first call contains a NULL information buffer\nand a buffer size of zero. The driver is expected to fill in\npVdInfo-\nByteCount with the required buffer size and return\nCLIENT_ERROR_BUFFER_TOO_SMALL. The WinStation driver allocates a\nbuffer of that size and retries the operation.\n\n\nThe data buffer pointed to by pVdinfo-\npBuffer must not be changed by\nthe virtual driver. The WinStation driver stores byte swap information\nin this buffer.\n\n\nThe parameter puiSize must be initialized to the size of the driver\ninformation structure.\n\n\nDriverOpen\n\n\nInitializes the virtual driver. The client engine calls this\nuser-written function once when the client is loaded. \n\n\nCalling Convention\n\n\nINT DriverOpen(\nPVD pVD, PVDOPEN pVdOpen)\nPUINT16 puiSize);\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npVD\n\n\nPointer to the virtual driver control structure. This pointer is passed on every call to the virtual driver.\n\n\n\n\n\n\npVdOpen\n\n\nPointer to the virtual driver Open structure.\n\n\n\n\n\n\npuiSize\n\n\nPointer to the size of the virtual driver Open structure. This is an output parameter.\n\n\n\n\n\n\n\n\nReturn Values\n\n\nIf the function succeeds, it returns CLIENT_STATUS_SUCCESS.\n\n\nIf the function fails, it returns the CLIENT_ERROR_* value\ncorresponding to the error conditio n; see clterr.h (in src/inc/) for a\nlist of error values beginning with CLIENT_ERROR\n\n\nRemarks\n\n\nThe code fragments in this section are taken from the vdping example.\n\n\nThe DriverOpen function must:\n\n\n\n\nAllocate a virtual channel.\nFill in a WDQUERYINFORMATION structure and call VdCallWd. The\nWinStation driver fills in the OpenVirtualChannel structure (including\nthe channel number) and the data in pVd.\n\n\n\n\nWDQUERYINFORMATION wdqi;\nOPENVIRTUALCHANNEL OpenVirtualChannel;\nwdqi.WdInformationClass = WdOpenVirtualChannel; wdqi.pWdInformation = \nOpenVirtualChannel;\nwdqi.WdInformationLength = sizeof(OPENVIRTUALCHANNEL); OpenVirtualChannel.pVCName = CTXPING_VIRTUAL_CHANNEL_NAME; rc = VdCallWd(pVd, WDxQUERYINFORMATION, \nwdqi);\n/* do error processing here */\n\n\n\n\n\nAfter the call to VdCallWd, the channel number is assigned in the\nOpenVirtualChannel structure's Channel element. Save the channel\nnumber and set the channel mask to indicate which channel this driver\nwill handle.\n\n\nFor example:\n\n\ng_usVirtualChannelNum = OpenVirtualChannel.Channel;\npVdOpen-\ngt;ChannelMask = (1L \nlt;\nlt; OpenVirtualChannel-\ngt;);\n\n\n\n\n\n. Optionally specify a pointer to a private data structure.\n\n\nIf you want the virtual driver to allocate memory for state data, it can\nhave a pointer to this data returned on each call by placing the pointer\nin the virtual driver structure, as follows:\n\n\npVd-\npPrivate = pMyStructure;\n\n\n\n\n\n.  Exchange entry point data with the WinStation driver.\n\n\nThe virtual driver must register a write hook with the client WinStation\ndriver. The write hook is the entry point of the virtual driver to be\ncalled when data is received for this virtual channel. The WinStation\ndriver returns pointers to functions that the driver must use to fill in\noutput buffers and sends data to the WinStation driver for transmission\nto the server.\n\n\nWDSETINFORMATION wdsi; \nVDWRITEHOOK vdwh;\n\n// Fill in a write hook structure \n\nvdwh.Type = g_usVirtualChannelNum; \nvdwh.pVdData = pVd;\nvdwh.pProc = (PVDWRITEPROCEDURE) ICADataArrival;\n\n// Fill in a set information structure \nwdsi.WdInformationClass = WdVirtualWriteHook; \nwdsi.pWdInformation = \nvdwh; \nwdsi.WdInformationLength = sizeof(VDWRITEHOOK); \nrc = VdCallWd( pVd, WDxSETINFORMATION, \nwdsi);\n/* do error processing here */\n\n\n\n\n\nDuring the registration of the write hook, the WinStation driver passes\nentry points for the output buffer virtual driver helper functions to\nthe virtual driver in the VDWRITEHOOK structure. The DriverOpen function\nsaves these in global variables so helper functions in the virtual\ndriver can use them. The WinStation driver also passes a pointer to the\nWinStation driver data area, which the DriverOpen function also saves\n(because it is the first argument to the virtual driver helper\nfunctions).\n\n\n// Record pointers to functions used\n// for sending data to the host. \npWd = vdwh.pWdData;\npOutBufReserve = vdwh.pOutBufReserveProc; \npOutBufAppend = vdwh.pOutBufAppenProc; \npOutBufWrite = vdwh.pOutBufWriteProc; \npAppendVdHeader = vdwh.pAppendVdHeaderProc;\n\n\n\n\n\n. Determine the version of the WinStation driver.\n\n\nNew virtual drivers should determine whether the WinStation driver\nsupports the new SendData API and \u201cno polling\u201d mode. Use the WdVirtualWriteHookEx information class to retrieve this information:\n\n\n// Do extra initialization to determine if\n// we are talking to an HPC client. \nwdsi.WdInformationClass = WdVirtualWriteHookEx;\nwdsi.pWdInformation = \nvdwhex;\nwdsi.WdInformationLength = sizeof(VDWRITEHOOKEX);\nvdwhex.usVersion = HPC_VD_API_VERSION_LEGACY;\n\n//Set version\n\n// to 0; older clients will do nothing\nrc = VdCallWd(pVd, WDxQUERYINFORMATION, \nwdsi, \nuiSize);\nif (CLIENT_STATUS_SUCCESS != rc)\n{\n    return(rc);\n}\ng_fIsHpc = (HPC_VD_API_VERSION_LEGACY != vdwhex.usVersion);\n\n// If version returned, this is HPC or later\ng_pSendData = vdwhex.pSendDataProc;     // save HPC SendData\n                                        // API address\n\n\n\n\n\nThe usVersion that is returned may be one of the following values:\n\n\ntypedef enum _HPC_VD_API_VERSION\n{\n    HPC_VD_API_VERSION_LEGACY = 0,          // legacy VDs\n    HPC_VD_API_VERSION_V1 =      1,         // VcSDK API version 1\n} HPC VD API VERSION;\n\n\n\n\n\nIf the usVersion returned is HPC_VD_API_VERSION_LEGACY, the engine\nis an earlier engine. Any other value indicates the newer engine. The\nactual version returned indicates the version of the API supported.\nCurrently the only other value that will be returned is\nHPC_VD_API_VERSION_V1. The g_fIsHpc flag should be set to indicate\nthat the newer API is available.\n\n\nThe WdVirtualWriteHookEx call also returns a pointer (g_pSendData).\nThis is a pointer to the SendData function. Save this value for later\nuse.\n\n\n. Set the API options in the WinStation driver.\n\n\nIf this virtual driver is loaded by the HPC WinStation driver, set the\nAPI options this driver will use:\n\n\nif(g_fIsHpc)\n{\n    WDSET_HPC_PROPERITES hpcProperties;\n    hpcProperties.usVersion = HPC_VD_API_VERSION_V1;\n    hpcProperties.pWdData = g_pWd; \n    hpcProperties.ulVdOptions = HPC_VD_OPTIONS_NO_POLLING; \n    wdsi.WdInformationClass = WdHpcProperties; \n    wdsi.pWdInformation = \nhpcProperties;\n    wdsi.WdInformationLength = sizeof(WDSET_HPC_PROPERITES); \n    rc = VdCallWd(pVd, WDxSETINFORMATION, \nwdsi, \nuiSize);\n    if(CLIENT_STATUS_SUCCESS != rc)\n    {\n        return(rc);\n    }\n}\n\n\n\n\n\nThe usVersion field is set to inform the engine of the version of the VD\nAPI that this driver will use. This allows the engine to maintain the\ncompatibility of the VD API for this driver at this level, even if the\nengine API changes in the future.\n\n\nThe pWdData pointer must point to the same data that was pointed to by\nthe pWdData field returned by the WdVirtualWriteHook VdCallWd call\nearlier in DriverOpen.\n\n\nThe ulVdOptions field is a bitwise OR of any of the following bit\ndefinitions:\n\n\ntypedef enum _HPC_VD_OPTIONS\n{\n    HPC_VD_OPTIONS_NO_POLLING =0x0001,  // Flag indicating that \n                                            //channels on this VD do not\n                                            // require send data polling \n    HPC_VD_OPTIONS_NO_COMPRESSION =0x0002       // Flag indicating\n                                                // that channels on this VD \n                                                // send data that does not \n                                                // need reducer compression\n} HPC_VD_OPTIONS;\n\n\n\n\n\n.  Allocate all memory needed by the driver and do any initialization.\n    You can obtain the maximum ICA buffer size from the\n    MaximumWriteSize element in the VDWRITEHOOK structure that\n    is returned.\n\n\n\n\nNote\nvdwh.MaximumWriteSize is one byte greater than the actual\n\n\n\n\n\n\nmaximum that you can use because it also includes the channel number.\n\n\ng_usMaxDataSize = vdwh.MaxiumWriteSize - 1; \nif(NULL == (pMyData = malloc( g_usMaxDataSize )))\n{\n    return(CLIENT_ERROR_NO_MEMORY);\n}\n\n\n\n\n\n  Return the size of the VDOPEN structure in \npuiSize\n. This is used\n    by the client engine to determine the version of the virtual\n    channel driver.\n\n\nDriverPoll\n\n\nAllows the virtual driver to check timers and other state information,\nsend queued data to the server, and perform any other required\nprocessing. This function may be called on a regular basis by the main\nclie nt poll loop.\n\n\nCalling Convention\n\n\nINT DriverPoll(\nPVD pVD,\nPVOID pVdPoll,\nPUINT16 puiSize);\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npVD\n\n\nPointer to a virtual driver control structure.\n\n\n\n\n\n\npVdPoll\n\n\nPointer to one of the driver poll information structures (DLLPOLL).\n\n\n\n\n\n\npuiSize\n\n\nPointer to the size of the driver poll information structure. This is an output parameter.\n\n\n\n\n\n\n\n\nReturn Values\n\n\nIf the function succeeds, it returns CLIENT_STATUS_SUCCESS.\n\n\nIf the driver has no data on this polling pass, it returns\nCLIENT_STATUS_NO_DATA.\n\n\nIf all virtual channels return CLIENT_STATUS_NO_DATA, the WinStation\ndriver may slow down the polling process.\n\n\nIf the sending of data via either the QueueVirtualWrite or the SendData\nfunction is blocked (CLIENT_ERROR_NO_OUTBUF), DriverPoll should\nreturn CLIENT_STATUS_ERROR_RETRY so the WinStation driver does not\nslow polling. The virtual driver should then try again the next time it\nis polled.\n\n\nIf the virtual driver cannot allocate an output buffer, it returns\nCLIENT_STATUS_ERROR_RETRY so the WinStation driver does not slow\npolling. The virtual driver then attempts to get an output buffer the\nnext time it is polled.\n\n\nIf polling has been disabled via the HPC_VD_OPTIONS_NO_POLLING\noption, DriverPoll will be called at least once, and then only when the\nvirtual driver has asked to be polled, or when it has asked to be\nnotified when a send operation can be retried. The return values have\nthe same setting as in the polling case above. Return\nCLIENT_STATUS_SUCCESS if all data has been sent successfully. Return\nCLIENT_STATUS_NO_DATA if there is no data available to send. Return\nCLIENT_STATUS_ERROR_RETRY if the send operation was blocked and the\nvirtual driver has more data to send.\n\n\nReturn values that begin with CLIENT_ERROR_* are fatal errors; the\nICA session will be disconnected.\n\n\nRemarks\n\n\nA virtual driver is not allowed to block while waiting for a desired\nresult (such as the availability of an output buffer).\n\n\nThe Ping example includes examples of processing types that can occur in\nDriver Poll.\n\n\nDriverQueryInformation\n\n\nGets run-time information from the virtual driver.\n\n\nCalling Convention\n\n\nINT DriverQueryInformation(\nPVD pVD,\nPVDQUERYINFORMATION pVdQueryInformation,\nPUINT16 puiSize);\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npVD\n\n\nPointer to a virtual driver control structure.\n\n\n\n\n\n\npVdQuery Information\n\n\nPointer to a structure that specifies the information to query and the results buffer.\n\n\n\n\n\n\npuiSize\n\n\nPointer to the size of the query information and resolves structure. This is an output parameter.\n\n\n\n\n\n\n\n\nReturn Value\n\n\nThe function returns CLIENT_STATUS_SUCCESS. \n\n\nRemarks\n\n\nThis function currently has no practical significance for virtual\ndrivers; it is provided for compatibility with the loadable module\ninterface. There are no general purpose query functions at this time\nother than LastError. The LastError query is accomplished through the\nDriverGetLastError function.\n\n\nDriverSetInformation\n\n\nSets run-time information in the virtual driver.\n\n\nCalling Convention\n\n\nINT DriverSetInformation(\nPVD pVD,\nPVDSETINFORMATION pVdSetInformation,\nPUINT16 puiSize);\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npVD\n\n\nPointer to a virtual driver control structure.\n\n\n\n\n\n\npVdSet Information\n\n\nPointer to a structure that specifies the information class, a pointer to any additional data, and the size in bytes of the additional data (if any).\n\n\n\n\n\n\npuiSize\n\n\nPointer to the size of the information structure. This is an input parameter.\n\n\n\n\n\n\n\n\nReturn Value\n\n\nThe function returns CLIENT_STATUS_SUCCESS. \n\n\nRemarks\n\n\nThis function can receive two information classes:\n\n\n\n\nVdDisableModule: When the connection is being closed.\n\n\nVdFlush: When WFPurgeInput or WFPurgeOutput is called by the server-side virtual channel application. The VdSetInformation structure contains a pointer to a VDFLUSH structure that specifies which purge function was called.\n\n\n\n\nSendData\n\n\nSends a virtual channel packet to the server, with a notification\noption.\n\n\nCalling Convention\n\n\nINT WFCAPI SendData(DWORD pWd, USHORT usChannel,\n                        LPBYTE pData,USHORT usLen,\n                        LPVOID pUserData, UINT32 uiFlags);\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nParameters\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npWd\n\n\nPointer to a WinStation driver control structure.\n\n\n\n\n\n\nus Channel\n\n\nThe virtual channel number\n\n\n\n\n\n\npData\n\n\nData passed as an argument to the callback\n\n\n\n\n\n\ncallback.usLen\n\n\nLenght in bytes of the data in the data buffer\n\n\n\n\n\n\nus User Data\n\n\nLength in b ytes of the data in the data buffer\n\n\n\n\n\n\nuiFlags\n\n\nFlags to control the operation of the SendData function. This value consists of a number of flags bitwise OR'ed together. Each of the flags controls some aspect of the SendData interface.\n\n\n\n\n\n\n\n\nCurrently there is only one flag defined. See the SENDDATA_* enum:\n\n\n\n\nSENDDATA_NOTIFY: If this flag is set,\nand when the SendData return code is CLIENT_ERROR_NO_OUTBUF\nindicating that the engine had no buffers to accommodate the outbound\npacket, the engine will notify the virtual driver later when it can\nretry the send operation. The notification occurs via the DriverPoll\nmethod.\n\n\n\n\nReturn Value\n\n\nThe SendData function will return one of the following values:\n\n\n\n\nCLIENT_STATUS_SUCCESS:\n\n\nThe data was copied into virtual write buffers.\n\n\nThe user's buffer is free.\n\n\nNo callback will occur, even if the SENDDATA_NOTIFY flag is set.\n\n\nThe next SendData call can be issued immediately.\n\n\n\n\n\n\n\n\nCLIENT_ERROR_NO_OUTBUF:\n\n\n\n\nThe virtual write could not be scheduled (out of\nVirtualWrite buffers). If a notification was requested, DriverPoll\nwill be driven with the notification at some later time when the\nvirtual driver should retry sending.\n\n\nIf no notification was requested, the virtual driver should return\nfrom DriverPoll and wait for the next poll before retrying\nthe send. This assumes that the virtual driver had selected the\npolled mode of operation.\n\n\n\n\n\n\n\n\nCLIENT_ERROR_BUFFER_STILL_BUSY: If the user has called SendData requesting a notification, and the return code was CLIENT_ERROR_NO_OUTBUF, the user must not issue\n    another SendData call until the notification has occurred. If\n    another call is issued before the notification occurs, the\n    CLIENT_ERROR_BUFFER_STILL_BUSY return code will result.\n\n\n\n\n\n\nCLIENT_ERROR_*: Any other error should cause the virtual driver and the session to close.\n\n\n\n\n\n\n\n\nNote\nIf the user has specified HPC_VD_OPTIONS_NO_POLLING in the HPC\n\n\n\n\n\n\nchannel options, then the virtual driver must assume that its DriverPoll\nfunction will not be called again after receiving one of these errors.\n\n\nRemarks\n\n\nThis function is used to send channel protocol to the server. The engine\neither accepts all the data, or refuses it all, in which case the\nchannel will need to retry later (normally inside DriverPoll).\n\n\nThe address for this function is obtained from the VDWRITEHOOKEX\nstructure after hook registration in pSendDataProc. The VDWRITEHOOK\nstructure provides pWd.\n\n\nICADataArrival\n\n\nThe WinStation driver calls this function when data is received on a\nvirtual channel being monitored by the driver. The address of this\nfunction is passed to the WinStation driver during DriverOpen.\n\n\nCalling Convention\n\n\nVOID wfcapi ICADataArrival(\n    PVD pVD,\n    USHORT uchan,\n    LPBYTE pBuf,\n    USHORT Length);\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npVD\n\n\nPointer to a virtual driver control structure.\n\n\n\n\n\n\nuChan\n\n\nVirtual channel number.\n\n\n\n\n\n\npBuf\n\n\nPointer to the data buffer containing the virtual channel data as sent by the server-side application.\n\n\n\n\n\n\nLength\n\n\nLength in bytes of the data in the buffer.\n\n\n\n\n\n\n\n\nReturn Value\n\n\nNo value is returned from this function.\n\n\nRemarks\n\n\nThis function name is a placeholder for a user-defined function; the\nactual function does not have to be called ICADataArrival, although it\ndoes have to match the function signature (parameters and return type).\nThe address of this function is given to the WinStation driver during\nDriverOpen. Although ICA prefixes packet control data to the virtual\nchannel data, this prefix is removed before this function is called.\n\n\nAfter the virtual driver returns from this function, the WinStation\ndriver considers the data de livered. The virtual driver must save\nwhatever information it needs from this packet if later processing is\nrequired.\n\n\nDo not allow this function to block. Use your own thread or the\nDriverPoll function (with polling enabled) for any required deferred\nprocessing.\n\n\nThe virtual driver can send data to the server on receipt of this data\nfrom within the ICADataArrival function, but be aware that the send\noperation may return an immediate error when buffers are not available\nto accommodate the send operation. The virtual driver may not block in this\nfunction waiting for the sending operation to complete.\n\n\nIf the virtual driver is handling multiple virtual channels, use the\nuChan parameter to determine the channel over which this data is to be\nsent. See DriverOpen for more information.\n\n\nmiGetPrivateProfileBool\n\n\nGets a Boolean value from a section of the Configuration Storage.\n\n\nCalling Convention\n\n\nINT miGetPrivateProfileBool(\n    PCHAR lpszSection,\n    PCHAR lpszEntry,\n    BOOL bDefault);\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nlpsz Section\n\n\nName of section to query.\n\n\n\n\n\n\nlpsz Entry\n\n\nName of entry to query.\n\n\n\n\n\n\nbDefault\n\n\nDefault value to use.\n\n\n\n\n\n\n\n\nReturn Values\n\n\nIf the requested entry is found, the entry value is returned; otherwise,\n\nbDefault\n is returned.\n\n\nRemarks\n\n\nA Boolean value of TRUE can be represented by on, yes, or true in the\nconfiguration files. All other strings are interpreted as FALSE.\n\n\nmiGetPrivateProfileInt\n\n\nGets an integer from a section of the Configuration Storage.\n\n\nCalling Convention\n\n\nINT miGetPrivateProfileInt(\n    PCHAR lpszSection,\n    PCHAR lpszEntry,\n    INT iDefault);\n\n\n### Parameters \n| Parameter | Description |\n|-----------|-------------|\n| lpsz Section | Name of section to query. |\n| lpsz Entry | Name of entry to query. |\n| iDefault | Default value to use. |\n\n\n### Return Values\n\nIf the requested entry is found, the entry value is returned; otherwise,\niDefault is returned.\n\n## miGetPrivateProfileLong\n\nGets a long value from a section of the configuration files.\n\n### Calling Convention\n\n\n\n\n\nINT miGetPrivateProfileLong(\n    PCHAR lpszSection,\n    PCHAR lpszEntry,\n    LONG lDefault);\n\n\n### Parameters \n\n| Parameter | Description |\n|-----------|-------------|\n| lpsz Section | Name of section to query. |\n| lpsz Entry | Name of entry to query. |\n| iDefault | Default value to use. |\n\n### Return Values\n\nIf the requested entry is found, the entry value is returned; otherwise,\nlDefault is returned.\n\n\n## miGetPrivateProfileString\n\nGets a string from a section of the configuration files.\n\n### Calling Convention\n\n\n\n\n\nINT miGetPrivateProfileString(\n    PCHAR lpszSection,\n    PCHAR lpszEntry,\n    PCHAR lpszDefault,\n    PCHAR lpszReturnBuffer, INT cbSize);\n\n\n### Parameters\n\n| Parameter | Description |\n|-----------|-------------|\n| lpsz Section | Name of section to query. |\n| lpsz Entry | Name of entry to query. |\n| lpsz Default | Default value to use. |\n| lpsz Return Buffer | Pointer to a buffer to hold results. |\n| cb Size | Size of lpszReturnBuffer in bytes. |\n\n\n### Return Values\n\nThis function returns the string length of the value returned in\nlpszReturnBuffer (not including the trailing NULL).\n\nIf the requested entry is found and the size of the entry string is less\nthan or equal to cbSize, the entry value is copied to lpszReturnBuffer;\notherwise, iDefault is copied to lpszReturnBuffer.\n\n### Remarks\n\nlpszDefault must fit in lpszReturnBuffer. The caller is responsible for\nallocating and deallocating lpszReturnBuffer.\n\nlpszReturnBuffer must be large enough to hold the maximum length entry\nstring, plus a NULL termination character. If an entry string does not\nfit in lpszReturnBuffer, the lpszDefault value is used.\n\n\n## QueueVirtualWrite\n\nA QueueVirtualWrite is an improved scatter gather interface. It queues a\nvirtual write and stimulates packet output if required allowing data to\nbe sent without having to wait for the poll.\n\n### Calling Convention\n\n\n\n\n\nint WFCAPI\nQueueVirtualWrite ( \nPWD pWd,\nSHORT Channel,\nLPMEMORY_SECTION pMemorySections, \nUSHORT NrOfSections,\nUSHORT Flag);\n\n\n### Parameters\n\n| Parameter | Description |\n|-----------|-------------|\n| pWd | Pointer to a WinStation driver control structure. |\n| Channel | The virtual channel number |\n| pMemory Sections | Pointer to an array of one or more elements of the structure MEMORY_SECTION (see below) containing the pure body of the protocol, i.e. excluding the virtual write header defining the channel and the length. This will get constructed by the QueueVirtualWrite function itself. Normally the protocol body will already be in a single contiguous block of memory. But if not, then multiple sections can be defined, and the destination function will copy all the different pieces into the appropriate internal WD queue.\n| Number Of Sections | The number of memory sections, normally 1. |\n| Flush Control | Indicates whether a \u2018flush to wire\u2019 operation should be triggered after the data has been successfully queued. If this value is FLUSH_IMMEDIATELY, then if the line conditions permit, the WD will attempt to send this new virtual write immediately over the wire, after also flushing any earlier queued data for the same or higher priority. If the data is not time critical (within the span of about 50ms), it may be better not to force a flush at this point, so that the data (if small) may go over the wire together with other data, so making better use of the wire bandwidth. The value to use if an immediate flush is not required is !FLUSH_IMMEDIATELY. |\n\n### Memory section\n\nThis structure has the definition:\n\n\n\n\n\ntypedef struct _MEMORY_SECTION\n{\n    UINT lenght;                        //Length of data\n    LPBYTE pSection;                    //Address of data\n}   MEMORY SECTION,     far * LPMEMORY SECTION;\n\n\n### Return Values\n\nIf the function succeeds, it returns CLIENT_STATUS_SUCCESS. If it\ncannot currently accept the data, it returns CLIENT_ERROR_NO_OUTBUF.\nIf being called from DriverPoll, then the return value for the\nDriverPoll should normally be set to CLIENT_STATUS_ERROR_RETRY in\nthis case. If the function fails, it returns an error code associated\nwith the failure; use GetLastError to get the extended error\ninformation.\n\n### Remarks\n\nThis function is used to send channel protocol to the server. The engine\neither accepts all the data, or refuses it all, in which case the\nchannel will need to retry later (normally inside DriverPoll).\n\nThe address for this function is obtained from the VDWRITEHOOK structure\nafter hook Registration in pQueueVirtualWriteProc. The VDWRITEHOOK\nstructure also provides pWd. Each successful call will ultimately result\nin a single block of protocol, with length = total length of all memory\nsections, being delivered to the server-side channel.\n\n## VdCallWd\n\nCalls the client WinStation driver to query and set information about\nthe virtual channel. This is the main method for the virtual driver to\naccess the WinStation driver. For general-purpose virtual channel\ndrivers, this sets the virtual write hook.\n\n### Calling Convention\n\n\n\n\n\nINT VdCallWd (\nPVD pVd,\nUSHORT ProcIndex,\nPVOID pParam);\n\n\n### Parameters\n\n| Parameter | Description |\n|-----------|-------------|\n| pVd | Pointer to a virtual driver control structure. |\n| Proc Index | Index of the WinStation driver routine to call. For virtual drivers, this can be either `WDxQUERYINFORMATION` or `WDxSETINFORMATION`.|\n| pParam | Pointer to a parameter structure. |\n\n\n### Return Values\n\nIf the function succeeds, it returns CLIENT_STATUS_SUCCESS.\n\nIf the function fails, it returns an error code associated with the\nfailure; use DriverGetLastError to get the extended error information.\n\n### Remarks\n\nThis function is a general purpose mechanism to call routines in the\nWinStation driver. The only valid uses of this function for a virtual\ndriver are to:.\n\n* To allocate the virtual channel using WDxQUERYINFORMATION\n* To exchange function pointers with the\nWinStation driver during DriverOpen using WDxSETINFORMATION\n\nFor more information, see DriverOpen or the Ping example.\n\nOn successful return, the VDWRITEHOOK structure contains pointers to the\noutput buffer virtual driver helper functions, and a pointer to the\nWinStation driver control block (which is needed for buffer calls).\n\n## WFVirtualChannelClose\n\nCloses an open virtual channel handle.\n\n### Calling Convention\n\n\n\n\n\nBOOL WINAPI WFVirtualChannelClose(IN HANDLE hChannelHandle);\n\n\n### Parameter\n\n| Parameter | Description |\n|-----------|-------------|\n| hChannel Handle | Handle to a previously opened virtual channel. Use WFVirtualChannelOpen to obtain a handle for a specific channel. |\n\n\n### Return Values\n\nIf the function succeeds, the return value is TRUE. If the function\nfails, the return value is FALSE; call GetLastError to get extended\nerror information.\n\n### Remarks\n\nWhen this function is called, any data waiting to be sent to the client\nis discarded. Call this function when the server-side virtual channel\napplication is finished.\n\nThe client- side virtual driver is not closed until the ICA session is\nclosed. If the virtual driver sends data to the server after the\nserver-side application closes, the data is queued on the server and\neventually discarded.\n\nTo prevent the virtual driver from sending data after the server-side\napplication closes, you might need to incorporate a packet type into\nyour virtual channel protocol to notify the virtual driver that the\nserver-side application is closing.\n\n## WFVirtualChannelOpen\n\nOpens a handle to a specific virtual channel.\n\n### Calling Convention\n\n\n\n\n\nHANDLE WINAPI WFVirtualChannelOpen(IN HANDLE hServer, \n                                    IN DWORD SessionId,\n                                    IN LPSTR pVirtualName // ANSI name \n                                    );\n\n\n### Parameters\n\n| Parameter | Description |\n|-----------|-------------|\n| hServer | Handle to a server running XenApp. To specify the current server, use the constant WF_CURRENT_SERVER_HANDLE. Use WFOpenServer to obtain a handle for a specific server. For more information about the WFOpenServer function, see the WFAPI SDK documentation. |\n| Session Id | Server session ID. Use the constant WF_CURRENT_SESSION to specify the current session. To obtain the session ID of a specific session, use WFEnumerateSessions. For more information about session IDs and WFEnumerateSessions, see the WFAPI SDK documentation. |\n| pVirtual Name | Pointer to the virtual channel name. This is an ASCII string (even when Unicode is defined) of no more than seven characters.\n\n\n### Return Values\n\nIf the function succeeds, it returns a handle to the specified virtual\nchannel. If the function fails, it returns NULL; call GetLastError for\nextended error information.\n\n### Remarks\n\nThe WinStation driver opens the channel by name, assigns a channel\nnumber, and returns a handle. The server -side virtual channel\napplication uses this handle to read and write data to the virtual\nchannel.\n\n## WFVirtualChannelPurgeInput\n\nPurges all queued input data sent from the client to the server on a\nspecific virtual channel.\n\n### Calling Convention\n\n\n\n\n\nBOOL WINAPI WFVirtualChannelPurgeInput(IN HANDLE hChannelHandle);\n\n\n### Parameter\n\n| Parameter | Description |\n|-----------|-------------|\n| hChannel Handle | Handle to a previously opened virtual channel. To obtain a handle for a specific channel, use WFVirtualChannelOpen. |\n\n### Return Values\n\nIf the function succeeds, the return value is TRUE. If the function\nfails, the return value is FALSE; call GetLastError to get extended\nerror information.\n\n### Remarks\n\nOutput buffers and queued data received from the client are discarded.\n\nThis function sends a message to the client WinStation driver, which\nthen calls the client virtual driver\u2019s\n\nDriverSetInformation function with the VdFlush information class. For\nmost virtual channels, this function is not necessary and you can use\nthe Ping example function without modification.\n\n## WFVirtualChannelPurgeOutput\n\nPurges all queued output data sent from the server to the client on a\nspecific virtual channel.\n\nExample of use: in an audio application in which the user starts playing\na different audio file, use this function to discard the audio that was\nqueued to be sent to the client from the first file played.\n\n### Calling Convention\n\n\n\n\n\nBOOL WINAPI WFVirtualChannelPurgeOutput(IN HANDLE hChannelHandle);\n\n\n###\n \nParameter\n\n\n\n|\n \nParameter\n \n|\n \nDescription\n \n|\n\n\n|-----------|-------------|\n\n\n|\n \nhChannel\n \nHandle\n \n|\n \nHandle\n \nto\n \na\n \npreviously\n \nopened\n \nvirtual\n \nchannel\n.\n \nTo\n \nobtain\n \na\n \nhandle\n \nfor\n \na\n \nspecific\n \nchannel\n,\n \nuse\n \nWFVirtualChannelOpen\n.\n \n|\n\n\n\n###\n \nReturn\n \nValues\n\n\n\nIf\n \nthe\n \nfunction\n \nsucceeds\n,\n \nthe\n \nreturn\n \nvalue\n \nis\n \nTRUE\n.\n \nIf\n \nthe\n \nfunction\n\n\nfails\n,\n \nthe\n \nreturn\n \nvalue\n \nis\n \nFALSE\n.\n \nCall\n \nGetLastError\n \nto\n \nget\n \nextended\n\n\nerror\n \ninformation\n.\n\n\n\n###\n \nRemarks\n\n\n\nOutput\n \nbuffers\n \nand\n \ndata\n \nqueued\n \nto\n \nbe\n \nsent\n \nto\n \nthe\n \nclient\n \nare\n \ndiscarded\n.\n\n\n\nThis\n \nfunction\n \nsends\n \na\n \nmessage\n \nto\n \nthe\n \nclient\n \nWinStation\n \ndriver\n,\n \nwhich\n\n\nthen\n \ncalls\n \nth\n \ne\n \nclient\n \nvirtual\n \ndriver\n\u2019\ns\n \nDriverSetInformation\n \nfunction\n\n\nwith\n \nthe\n \nVdFlush\n \ninformation\n \nclass\n.\n \nFor\n \nmost\n \nvirtual\n \nchannels\n,\n \nthis\n\n\nfunction\n \nis\n \nnot\n \nnecessary\n \nand\n \nyou\n \ncan\n \nuse\n \nthe\n \nPing\n \nexample\n \nfunction\n\n\nwithout\n \nmodification\n.\n\n\n\n##\n \nWFVirtualChannelQuery\n\n\n\nReturns\n \ndata\n \nrelated\n \nto\n \na\n \nvirtual\n \nchannel\n.\n \nThis\n \ninformation\n \nis\n \nobtained\n\n\nwhen\n \nthe\n \nICA\n \nconnection\n \nis\n \ninitiated\n \nand\n \nthe\n \nWinStation\n \ndriver\n \ncalls\n \nthe\n\n\nDriverInfo\n \nfunction\n.\n\n\n\n###\n \nCalling\n \nConvention\n\n\n\n\n\n\nBOOL WINAPI WFVirtualChannelQuery(IN HANDLE hChannelHandle,\n                                   IN WF_VIRTUAL_CLASS VirtualClass, \n                                   OUT PVOID *ppBuffer,\n                                   OUT DWORD *pBytesReturned \n                                   );\n\n\n### Parameters\n\n| Parameter | Description |\n|-----------|-------------|\n| hChannel Handle | Handle to a previously opened virtual channel. To obtain a handle for a specific channel, use WFVirtualChannelOpen. |\n| Virtual Class | Type of information to request. Currently, the only defined value is WFVirtualClientData , which returns virtual channel client module data. |\n| ppBuffer | Pointer to the address of a variable to receive the data. The buffer is allocated within this fun ction and is deallocated by using WFFreeMemory. |\n| pBytes Returned | Pointer to a DWORD that is updated with the length of the data returned in the allocated buffer (upon successful return). |\n\n### Return Values\n\nIf the function succeeds, the return value is TRUE. If the function\nfails, the return value is F ALSE; Call GetLastError to get extended\nerror information.\n\n### Remarks\n\nppBuffer begins with the structure VD_C2H, which begins with the\nstructure MODULE_C2H. These two structures are defined in Ica-c2h.h (in\nsrc\\inc\\). See the Ping example for more information.\n\n## WFVirtualChannelRead\n\nReads data from a virtual channel. \n\n### Calling Convention\n\n\n\n\n\nBOOL WINAPI WFVirtualChannelRead(IN HANDLE hChannelHandle,\n                                  IN ULONG TimeOut, \n                                  OUT PCHAR pBuffer, \n                                  IN ULONG BufferSize,\n                                  OUT PULONG pBytesRead\n                                  );\n\n\n###\n \nParameters\n\n\n\n|\n \nParameter\n \n|\n \nDescription\n \n|\n\n\n|-----------|-------------|\n\n\n|\n \nhChannel\n \nHandle\n \n|\n \nHandle\n \nto\n \na\n \npreviously\n \nopened\n \nvirtual\n \nchannel\n.\n \nTo\n \nobtain\n \na\n \nhandle\n \nfor\n \na\n \nspecific\n \nchannel\n,\n \nuse\n \nWFVirtualChannelOpen\n.\n \n|\n\n\n|\n \nTimeOut\n \n|\n \nLength\n \nof\n \ntime\n \nto\n \nwait\n \nfor\n \ndata\n \n(\nin\n \nmilliseconds\n).\n \nIf\n \nthis\n \nvalue\n \nis\n \nzero\n,\n \nthe\n \nfunction\n \nreturns\n \nimmediately\n \nwhether\n \nor\n \nnot\n \ndata\n \nis\n \navailable\n.\n \nIf\n \nthis\n \nvalue\n \nis\n \n-\n1\n,\n \nthe\n \nfunction\n \ncontinues\n \nwaiting\n \nuntil\n \nthere\n \nis\n \ndata\n \nto\n \nread\n.\n \n|\n\n\n|\n \npBuffer\n \n|\n \nBuffer\n \nto\n \nreceive\n \nthe\n \ndata\n \nread\n \nfrom\n \nthe\n \nvirtual\n \nchannel\n.\n \n|\n\n\n|\n \nBuffer\n \nSize\n \n|\n \nSize\n \nin\n \nbytes\n \nof\n \nthe\n \nbuffer\n \nneeded\n.\n \n|\n\n\n|\n \npBytes\n \nRead\n \n|\n \nPointer\n \nto\n \na\n \nvariable\n \nthat\n \nreceives\n \nthe\n \nnumber\n \nof\n \nbytes\n \nread\n.\n \n|\n\n\n\n###\n \nReturn\n \nValues\n\n\n\nIf\n \nthe\n \nfunction\n \nsucceeds\n,\n \nthe\n \nreturn\n \nvalue\n \nis\n \nTRUE\n.\n \nIf\n \nthe\n \nfunction\n\n\nfails\n,\n \nthe\n \nreturn\n \nvalue\n \nis\n \nFALSE\n;\n \ncall\n \nGetLastError\n \nto\n \nget\n \nextended\n\n\nerror\n \ninformation\n.\n\n\n\n###\n \nRemarks\n\n\n\nThe\n \ndeveloper\n \ndetermines\n \nthe\n \nBufferSize\n,\n \nwhich\n \ncan\n \nbe\n \nany\n \nlength\n \nup\n \nto\n\n\nthe\n \nmaximum\n \nsize\n \nsupported\n \nby\n \nthe\n \nICA\n \nconnection\n.\n \nThis\n \nsize\n \nis\n\n\nindependent\n \nof\n \nsize\n \nrestrictions\n \non\n \nthe\n \nlower\n-\nlayer\n \ntransport\n.\n\n\n\n*\n \nIf\n \nthe\n \nserver\n \nis\n \nrunning\n \nXenApp\n,\n \nthe\n\n\nmaximum\n \npacket\n \nsize\n \nis\n \n5000\n \nbytes\n \n(\n4996\n \nbytes\n \nof\n \ndata\n \nplus\n \nthe\n \n4\n-\nbyte\n\n\npacket\n \noverhead\n \ngenerated\n \nby\n \nthe\n \nICA\n \ndatastream\n \nmanager\n).\n\n\n\nIf\n \nmore\n \ndata\n \nis\n \nreceived\n \nthan\n \nthe\n \nbuffer\n \ncan\n \nhold\n,\n \nthe\n \nentire\n \npacket\n \nis\n\n\ndiscarded\n.\n\n\n\nIf\n \nno\n \ndata\n \nis\n \nreceived\n,\n \npBuffer\n \nand\n \npBytesRead\n \nare\n \nunmodified\n.\n \nThe\n\n\nfunction\n \nfails\n \nif\n \nthe\n \nread\n \ntimes\n \nout\n.\n\n\n\nThe\n \nserver\n-\nside\n \nvirtual\n \nchannel\n \napplication\n \nis\n \nnot\n \nnotified\n \nwhen\n \ndata\n \nis\n\n\nreceived\n.\n \nInstead\n,\n \nthe\n \ndata\n \nis\n \nqueued\n \nuntil\n \nthe\n \napplication\n \nuses\n\n\nWFVirtualChannelRead\n \nto\n \nretrieve\n \nit\n.\n\n\n\n##\n \nWFVirtualChannelWrite\n\n\n\nWrites\n \ndata\n \nto\n \na\n \nvirtual\n \nchannel\n.\n\n\n\n###\n \nCalling\n \nConvention\n\n\n\n\n\n\nBOOL WINAPI WFVirtualChannelWrite   (IN HANDLE hChannelHandle,\n                                     IN PCHAR pBuffer, \n                                     IN ULONG Length,\n                                     OUT PULONG pBytesWritten\n                                     );\n\n\n```\n\n\nParameters\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nhChannel Handle\n\n\nHandle to a previously opened virtual channel. To obtain a handle for a specific channel, use WFVirtualChannelOpen.\n\n\n\n\n\n\npBuffer\n\n\nBuffer containing data to write to the virtual channel. This must be four bytes larger than the largest buffer written by the client.\n\n\n\n\n\n\nLength\n\n\nSize in bytes of the buffer needed. This must be four bytes larger than the data written by the application.\n\n\n\n\n\n\npBytes Written\n\n\nPointer to a ULONG variable that receives the number of bytes written.\n\n\n\n\n\n\n\n\nReturn Values\n\n\nIf the data is sent, the return value is TRUE.\n\n\nIf the data is not sent, the return value is FALSE; call GetLastError to\nget extended error information.\n\n\nRemarks\n\n\nThe developer determines the Length, which can be any length up to the\nmaximum size supported by the ICA connection. This size is independent\nof size restrictions on the lower-layer transport.\n\n\n\n\nIf the server is running XenApp, the\nmaximum packet size is 5000 bytes (4996 bytes of data plus the 4-byte\npacket overhead generated by the ICA datastream manager).\n\n\n\n\nThe WinStation driver calls the client virtual driver's ICADataArrival\nfunction.", 
            "title": "Programming Reference"
        }, 
        {
            "location": "/programming-reference/#programming-reference", 
            "text": "For function summaries , see:   Server-Side Functions Overview  Client-Side Functions Overview", 
            "title": "Programming Reference"
        }, 
        {
            "location": "/programming-reference/#driverclose", 
            "text": "The WinStation driver calls this function prior to unloading the\nvirtual driver, when the ICA connection is being terminated.", 
            "title": "DriverClose"
        }, 
        {
            "location": "/programming-reference/#calling-convention", 
            "text": "INT Driverclose\n    ( PVD pVD,\n    PDLLCLOSE pVdClose, \n    PUINT16 puiSize);", 
            "title": "Calling Convention"
        }, 
        {
            "location": "/programming-reference/#parameters", 
            "text": "Parameter  Description      pVD  Pointer to a virtual driver control structure.    pVdClose  Pointer to a standard driver close information structure.    puiSize  Pointer to the size of the driver close information structure. This is an input parameter.", 
            "title": "Parameters"
        }, 
        {
            "location": "/programming-reference/#return-values", 
            "text": "If the function succeeds the return value is CLIENT_STATUS_SUCCESS.  If the function fails, the return value is the CLIENT_ERROR_* value\ncorresponding to the error condition; see clterr.h (in src/inc/) for a\nlist of error values beginning with CLIENT_ERROR.", 
            "title": "Return Values"
        }, 
        {
            "location": "/programming-reference/#remarks", 
            "text": "When DriverClose is called, all private driver data is freed. The\nvirtual driver does not need to deallocate the virtual channel or write\nhooks.  The pVdClose structure currently contains one element \u2013 NotUsed. This\nstructure can be ignored.", 
            "title": "Remarks"
        }, 
        {
            "location": "/programming-reference/#drivergetlasterror", 
            "text": "This function is not used but is available for linking with the common\nfront end, VDAPI.", 
            "title": "DriverGetLastError"
        }, 
        {
            "location": "/programming-reference/#calling-convention_1", 
            "text": "INT DriverGetLastError(\nPVD pVD,\nPVDLASSTERROR pVdLastError);", 
            "title": "Calling Convention"
        }, 
        {
            "location": "/programming-reference/#parameters_1", 
            "text": "Parameter  Description      pVD  Pointer to a virtual driver control structure.    pVdLast Error  Pointer to a structure that receives the last error information.", 
            "title": "Parameters"
        }, 
        {
            "location": "/programming-reference/#return-value", 
            "text": "The driver returns CLIENT_STATUS_SUCCESS.", 
            "title": "Return Value"
        }, 
        {
            "location": "/programming-reference/#remarks_1", 
            "text": "This function currently has no practical significance for virtual\ndrivers; it is provided for compatibility with the loadable module\ninterface.", 
            "title": "Remarks"
        }, 
        {
            "location": "/programming-reference/#driverinfo", 
            "text": "Gets information about the virtual driver, such as the version level of\nthe driver.", 
            "title": "DriverInfo"
        }, 
        {
            "location": "/programming-reference/#calling-convention_2", 
            "text": "INT DriverInfo(\nPVD pVD,\nPDLLINFO pVdInfo,\nPUINT16 puiSize);", 
            "title": "Calling Convention"
        }, 
        {
            "location": "/programming-reference/#parameters_2", 
            "text": "Parameter  Description      pVD  Pointer to a virtual driver control structure.    pVdInfo  Pointer to a standard driver information structure.    puiSize  Pointer to the size of the driver information structure. This is an output parameter.", 
            "title": "Parameters"
        }, 
        {
            "location": "/programming-reference/#return-value_1", 
            "text": "If the function succeeds, it returns CLIENT_STATUS_SUCCESS.  If the function fails because the buffer pointed to by pVdInfo is too\nsmall, it returns CLIENT_ERROR_BUFFER_TOO_SMALL. Normally, when a\nCLIENT_ERROR_ result code is returned, the ICA session is\ndisconnected. CLIENT_ERROR_BUFFER_ TOO_SMALL is an exception and\ndoes not result in the ICA session being disconnected. Instead, the\nWinStation driver attempts to call DriverInfo again with the ByteCount\nof pVdInfo returned by the failed call.", 
            "title": "Return Value"
        }, 
        {
            "location": "/programming-reference/#remarks_2", 
            "text": "When the client starts, it calls this function to retrieve\nmodule-specific information for transmission to the host. This\ninformation is returned to the server side of the virtual channel by\nWFVirtualChannelQuery.  The virtual driver must support this call by returning a structure in\nthe pVdInfo buffer. This structure can be a developer-defined virtual\nchannel-specific structure, but it must begin with a VD_C2H structure,\nwhich in turn begins with a MODULE_C2H structure. All fields of the\nVD_C2H structure must be filled in except for the ChannelMask field.\nSee ica-c2h.h (in src/inc/) for definitions of these structures.  The virtual driver must first check the size of the information buffer\ngiven against the size that the virtual driver requires (the VD_C2H\nstructure). The size of the input buffer is given in pVdInfo\n- ByteCount.  If the buffer is too small to store the information that the driver\nneeds to send, the correct size is filled into the ByteCount field and\nthe driver returns CLIENT_ERROR_BUFFER_TOO_SMALL.  If the buffer is large enough, the driver must fill it with a\nmodule-defined structure. At a minimum, this structure must contain a\nVD_C2H structure. The VD_C2H structure must be the first data in the\nbuffer; additional channel-specific data can follow. All relevant fields\nof this structure are filled in by this function. The flow control\nmethod is specified in the VDFLOW structure (an element of the VD_C2H\nstructure). The Ping example contains a flow control selection.  The WinStation driver calls this function twice at initialization, after\ncalling DriverOpen. The first call contains a NULL information buffer\nand a buffer size of zero. The driver is expected to fill in\npVdInfo- ByteCount with the required buffer size and return\nCLIENT_ERROR_BUFFER_TOO_SMALL. The WinStation driver allocates a\nbuffer of that size and retries the operation.  The data buffer pointed to by pVdinfo- pBuffer must not be changed by\nthe virtual driver. The WinStation driver stores byte swap information\nin this buffer.  The parameter puiSize must be initialized to the size of the driver\ninformation structure.", 
            "title": "Remarks"
        }, 
        {
            "location": "/programming-reference/#driveropen", 
            "text": "Initializes the virtual driver. The client engine calls this\nuser-written function once when the client is loaded.", 
            "title": "DriverOpen"
        }, 
        {
            "location": "/programming-reference/#calling-convention_3", 
            "text": "INT DriverOpen(\nPVD pVD, PVDOPEN pVdOpen)\nPUINT16 puiSize);", 
            "title": "Calling Convention"
        }, 
        {
            "location": "/programming-reference/#parameters_3", 
            "text": "Parameter  Description      pVD  Pointer to the virtual driver control structure. This pointer is passed on every call to the virtual driver.    pVdOpen  Pointer to the virtual driver Open structure.    puiSize  Pointer to the size of the virtual driver Open structure. This is an output parameter.", 
            "title": "Parameters"
        }, 
        {
            "location": "/programming-reference/#return-values_1", 
            "text": "If the function succeeds, it returns CLIENT_STATUS_SUCCESS.  If the function fails, it returns the CLIENT_ERROR_* value\ncorresponding to the error conditio n; see clterr.h (in src/inc/) for a\nlist of error values beginning with CLIENT_ERROR", 
            "title": "Return Values"
        }, 
        {
            "location": "/programming-reference/#remarks_3", 
            "text": "The code fragments in this section are taken from the vdping example.  The DriverOpen function must:   Allocate a virtual channel.\nFill in a WDQUERYINFORMATION structure and call VdCallWd. The\nWinStation driver fills in the OpenVirtualChannel structure (including\nthe channel number) and the data in pVd.   WDQUERYINFORMATION wdqi;\nOPENVIRTUALCHANNEL OpenVirtualChannel;\nwdqi.WdInformationClass = WdOpenVirtualChannel; wdqi.pWdInformation =  OpenVirtualChannel;\nwdqi.WdInformationLength = sizeof(OPENVIRTUALCHANNEL); OpenVirtualChannel.pVCName = CTXPING_VIRTUAL_CHANNEL_NAME; rc = VdCallWd(pVd, WDxQUERYINFORMATION,  wdqi);\n/* do error processing here */  After the call to VdCallWd, the channel number is assigned in the\nOpenVirtualChannel structure's Channel element. Save the channel\nnumber and set the channel mask to indicate which channel this driver\nwill handle.  For example:  g_usVirtualChannelNum = OpenVirtualChannel.Channel;\npVdOpen- gt;ChannelMask = (1L  lt; lt; OpenVirtualChannel- gt;);  . Optionally specify a pointer to a private data structure.  If you want the virtual driver to allocate memory for state data, it can\nhave a pointer to this data returned on each call by placing the pointer\nin the virtual driver structure, as follows:  pVd- pPrivate = pMyStructure;  .  Exchange entry point data with the WinStation driver.  The virtual driver must register a write hook with the client WinStation\ndriver. The write hook is the entry point of the virtual driver to be\ncalled when data is received for this virtual channel. The WinStation\ndriver returns pointers to functions that the driver must use to fill in\noutput buffers and sends data to the WinStation driver for transmission\nto the server.  WDSETINFORMATION wdsi; \nVDWRITEHOOK vdwh;\n\n// Fill in a write hook structure \n\nvdwh.Type = g_usVirtualChannelNum; \nvdwh.pVdData = pVd;\nvdwh.pProc = (PVDWRITEPROCEDURE) ICADataArrival;\n\n// Fill in a set information structure \nwdsi.WdInformationClass = WdVirtualWriteHook; \nwdsi.pWdInformation =  vdwh; \nwdsi.WdInformationLength = sizeof(VDWRITEHOOK); \nrc = VdCallWd( pVd, WDxSETINFORMATION,  wdsi);\n/* do error processing here */  During the registration of the write hook, the WinStation driver passes\nentry points for the output buffer virtual driver helper functions to\nthe virtual driver in the VDWRITEHOOK structure. The DriverOpen function\nsaves these in global variables so helper functions in the virtual\ndriver can use them. The WinStation driver also passes a pointer to the\nWinStation driver data area, which the DriverOpen function also saves\n(because it is the first argument to the virtual driver helper\nfunctions).  // Record pointers to functions used\n// for sending data to the host. \npWd = vdwh.pWdData;\npOutBufReserve = vdwh.pOutBufReserveProc; \npOutBufAppend = vdwh.pOutBufAppenProc; \npOutBufWrite = vdwh.pOutBufWriteProc; \npAppendVdHeader = vdwh.pAppendVdHeaderProc;  . Determine the version of the WinStation driver.  New virtual drivers should determine whether the WinStation driver\nsupports the new SendData API and \u201cno polling\u201d mode. Use the WdVirtualWriteHookEx information class to retrieve this information:  // Do extra initialization to determine if\n// we are talking to an HPC client. \nwdsi.WdInformationClass = WdVirtualWriteHookEx;\nwdsi.pWdInformation =  vdwhex;\nwdsi.WdInformationLength = sizeof(VDWRITEHOOKEX);\nvdwhex.usVersion = HPC_VD_API_VERSION_LEGACY;\n\n//Set version\n\n// to 0; older clients will do nothing\nrc = VdCallWd(pVd, WDxQUERYINFORMATION,  wdsi,  uiSize);\nif (CLIENT_STATUS_SUCCESS != rc)\n{\n    return(rc);\n}\ng_fIsHpc = (HPC_VD_API_VERSION_LEGACY != vdwhex.usVersion);\n\n// If version returned, this is HPC or later\ng_pSendData = vdwhex.pSendDataProc;     // save HPC SendData\n                                        // API address  The usVersion that is returned may be one of the following values:  typedef enum _HPC_VD_API_VERSION\n{\n    HPC_VD_API_VERSION_LEGACY = 0,          // legacy VDs\n    HPC_VD_API_VERSION_V1 =      1,         // VcSDK API version 1\n} HPC VD API VERSION;  If the usVersion returned is HPC_VD_API_VERSION_LEGACY, the engine\nis an earlier engine. Any other value indicates the newer engine. The\nactual version returned indicates the version of the API supported.\nCurrently the only other value that will be returned is\nHPC_VD_API_VERSION_V1. The g_fIsHpc flag should be set to indicate\nthat the newer API is available.  The WdVirtualWriteHookEx call also returns a pointer (g_pSendData).\nThis is a pointer to the SendData function. Save this value for later\nuse.  . Set the API options in the WinStation driver.  If this virtual driver is loaded by the HPC WinStation driver, set the\nAPI options this driver will use:  if(g_fIsHpc)\n{\n    WDSET_HPC_PROPERITES hpcProperties;\n    hpcProperties.usVersion = HPC_VD_API_VERSION_V1;\n    hpcProperties.pWdData = g_pWd; \n    hpcProperties.ulVdOptions = HPC_VD_OPTIONS_NO_POLLING; \n    wdsi.WdInformationClass = WdHpcProperties; \n    wdsi.pWdInformation =  hpcProperties;\n    wdsi.WdInformationLength = sizeof(WDSET_HPC_PROPERITES); \n    rc = VdCallWd(pVd, WDxSETINFORMATION,  wdsi,  uiSize);\n    if(CLIENT_STATUS_SUCCESS != rc)\n    {\n        return(rc);\n    }\n}  The usVersion field is set to inform the engine of the version of the VD\nAPI that this driver will use. This allows the engine to maintain the\ncompatibility of the VD API for this driver at this level, even if the\nengine API changes in the future.  The pWdData pointer must point to the same data that was pointed to by\nthe pWdData field returned by the WdVirtualWriteHook VdCallWd call\nearlier in DriverOpen.  The ulVdOptions field is a bitwise OR of any of the following bit\ndefinitions:  typedef enum _HPC_VD_OPTIONS\n{\n    HPC_VD_OPTIONS_NO_POLLING =0x0001,  // Flag indicating that \n                                            //channels on this VD do not\n                                            // require send data polling \n    HPC_VD_OPTIONS_NO_COMPRESSION =0x0002       // Flag indicating\n                                                // that channels on this VD \n                                                // send data that does not \n                                                // need reducer compression\n} HPC_VD_OPTIONS;  .  Allocate all memory needed by the driver and do any initialization.\n    You can obtain the maximum ICA buffer size from the\n    MaximumWriteSize element in the VDWRITEHOOK structure that\n    is returned.   Note vdwh.MaximumWriteSize is one byte greater than the actual    maximum that you can use because it also includes the channel number.  g_usMaxDataSize = vdwh.MaxiumWriteSize - 1; \nif(NULL == (pMyData = malloc( g_usMaxDataSize )))\n{\n    return(CLIENT_ERROR_NO_MEMORY);\n}    Return the size of the VDOPEN structure in  puiSize . This is used\n    by the client engine to determine the version of the virtual\n    channel driver.", 
            "title": "Remarks"
        }, 
        {
            "location": "/programming-reference/#driverpoll", 
            "text": "Allows the virtual driver to check timers and other state information,\nsend queued data to the server, and perform any other required\nprocessing. This function may be called on a regular basis by the main\nclie nt poll loop.", 
            "title": "DriverPoll"
        }, 
        {
            "location": "/programming-reference/#calling-convention_4", 
            "text": "INT DriverPoll(\nPVD pVD,\nPVOID pVdPoll,\nPUINT16 puiSize);", 
            "title": "Calling Convention"
        }, 
        {
            "location": "/programming-reference/#parameters_4", 
            "text": "Parameter  Description      pVD  Pointer to a virtual driver control structure.    pVdPoll  Pointer to one of the driver poll information structures (DLLPOLL).    puiSize  Pointer to the size of the driver poll information structure. This is an output parameter.", 
            "title": "Parameters"
        }, 
        {
            "location": "/programming-reference/#return-values_2", 
            "text": "If the function succeeds, it returns CLIENT_STATUS_SUCCESS.  If the driver has no data on this polling pass, it returns\nCLIENT_STATUS_NO_DATA.  If all virtual channels return CLIENT_STATUS_NO_DATA, the WinStation\ndriver may slow down the polling process.  If the sending of data via either the QueueVirtualWrite or the SendData\nfunction is blocked (CLIENT_ERROR_NO_OUTBUF), DriverPoll should\nreturn CLIENT_STATUS_ERROR_RETRY so the WinStation driver does not\nslow polling. The virtual driver should then try again the next time it\nis polled.  If the virtual driver cannot allocate an output buffer, it returns\nCLIENT_STATUS_ERROR_RETRY so the WinStation driver does not slow\npolling. The virtual driver then attempts to get an output buffer the\nnext time it is polled.  If polling has been disabled via the HPC_VD_OPTIONS_NO_POLLING\noption, DriverPoll will be called at least once, and then only when the\nvirtual driver has asked to be polled, or when it has asked to be\nnotified when a send operation can be retried. The return values have\nthe same setting as in the polling case above. Return\nCLIENT_STATUS_SUCCESS if all data has been sent successfully. Return\nCLIENT_STATUS_NO_DATA if there is no data available to send. Return\nCLIENT_STATUS_ERROR_RETRY if the send operation was blocked and the\nvirtual driver has more data to send.  Return values that begin with CLIENT_ERROR_* are fatal errors; the\nICA session will be disconnected.", 
            "title": "Return Values"
        }, 
        {
            "location": "/programming-reference/#remarks_4", 
            "text": "A virtual driver is not allowed to block while waiting for a desired\nresult (such as the availability of an output buffer).  The Ping example includes examples of processing types that can occur in\nDriver Poll.", 
            "title": "Remarks"
        }, 
        {
            "location": "/programming-reference/#driverqueryinformation", 
            "text": "Gets run-time information from the virtual driver.", 
            "title": "DriverQueryInformation"
        }, 
        {
            "location": "/programming-reference/#calling-convention_5", 
            "text": "INT DriverQueryInformation(\nPVD pVD,\nPVDQUERYINFORMATION pVdQueryInformation,\nPUINT16 puiSize);", 
            "title": "Calling Convention"
        }, 
        {
            "location": "/programming-reference/#parameters_5", 
            "text": "Parameter  Description      pVD  Pointer to a virtual driver control structure.    pVdQuery Information  Pointer to a structure that specifies the information to query and the results buffer.    puiSize  Pointer to the size of the query information and resolves structure. This is an output parameter.", 
            "title": "Parameters"
        }, 
        {
            "location": "/programming-reference/#return-value_2", 
            "text": "The function returns CLIENT_STATUS_SUCCESS.", 
            "title": "Return Value"
        }, 
        {
            "location": "/programming-reference/#remarks_5", 
            "text": "This function currently has no practical significance for virtual\ndrivers; it is provided for compatibility with the loadable module\ninterface. There are no general purpose query functions at this time\nother than LastError. The LastError query is accomplished through the\nDriverGetLastError function.", 
            "title": "Remarks"
        }, 
        {
            "location": "/programming-reference/#driversetinformation", 
            "text": "Sets run-time information in the virtual driver.", 
            "title": "DriverSetInformation"
        }, 
        {
            "location": "/programming-reference/#calling-convention_6", 
            "text": "INT DriverSetInformation(\nPVD pVD,\nPVDSETINFORMATION pVdSetInformation,\nPUINT16 puiSize);", 
            "title": "Calling Convention"
        }, 
        {
            "location": "/programming-reference/#parameters_6", 
            "text": "Parameter  Description      pVD  Pointer to a virtual driver control structure.    pVdSet Information  Pointer to a structure that specifies the information class, a pointer to any additional data, and the size in bytes of the additional data (if any).    puiSize  Pointer to the size of the information structure. This is an input parameter.", 
            "title": "Parameters"
        }, 
        {
            "location": "/programming-reference/#return-value_3", 
            "text": "The function returns CLIENT_STATUS_SUCCESS.", 
            "title": "Return Value"
        }, 
        {
            "location": "/programming-reference/#remarks_6", 
            "text": "This function can receive two information classes:   VdDisableModule: When the connection is being closed.  VdFlush: When WFPurgeInput or WFPurgeOutput is called by the server-side virtual channel application. The VdSetInformation structure contains a pointer to a VDFLUSH structure that specifies which purge function was called.", 
            "title": "Remarks"
        }, 
        {
            "location": "/programming-reference/#senddata", 
            "text": "Sends a virtual channel packet to the server, with a notification\noption.", 
            "title": "SendData"
        }, 
        {
            "location": "/programming-reference/#calling-convention_7", 
            "text": "INT WFCAPI SendData(DWORD pWd, USHORT usChannel,\n                        LPBYTE pData,USHORT usLen,\n                        LPVOID pUserData, UINT32 uiFlags);", 
            "title": "Calling Convention"
        }, 
        {
            "location": "/programming-reference/#parameters_7", 
            "text": "Parameters  Description      pWd  Pointer to a WinStation driver control structure.    us Channel  The virtual channel number    pData  Data passed as an argument to the callback    callback.usLen  Lenght in bytes of the data in the data buffer    us User Data  Length in b ytes of the data in the data buffer    uiFlags  Flags to control the operation of the SendData function. This value consists of a number of flags bitwise OR'ed together. Each of the flags controls some aspect of the SendData interface.     Currently there is only one flag defined. See the SENDDATA_* enum:   SENDDATA_NOTIFY: If this flag is set,\nand when the SendData return code is CLIENT_ERROR_NO_OUTBUF\nindicating that the engine had no buffers to accommodate the outbound\npacket, the engine will notify the virtual driver later when it can\nretry the send operation. The notification occurs via the DriverPoll\nmethod.", 
            "title": "Parameters"
        }, 
        {
            "location": "/programming-reference/#return-value_4", 
            "text": "The SendData function will return one of the following values:   CLIENT_STATUS_SUCCESS:  The data was copied into virtual write buffers.  The user's buffer is free.  No callback will occur, even if the SENDDATA_NOTIFY flag is set.  The next SendData call can be issued immediately.     CLIENT_ERROR_NO_OUTBUF:   The virtual write could not be scheduled (out of\nVirtualWrite buffers). If a notification was requested, DriverPoll\nwill be driven with the notification at some later time when the\nvirtual driver should retry sending.  If no notification was requested, the virtual driver should return\nfrom DriverPoll and wait for the next poll before retrying\nthe send. This assumes that the virtual driver had selected the\npolled mode of operation.     CLIENT_ERROR_BUFFER_STILL_BUSY: If the user has called SendData requesting a notification, and the return code was CLIENT_ERROR_NO_OUTBUF, the user must not issue\n    another SendData call until the notification has occurred. If\n    another call is issued before the notification occurs, the\n    CLIENT_ERROR_BUFFER_STILL_BUSY return code will result.    CLIENT_ERROR_*: Any other error should cause the virtual driver and the session to close.     Note If the user has specified HPC_VD_OPTIONS_NO_POLLING in the HPC    channel options, then the virtual driver must assume that its DriverPoll\nfunction will not be called again after receiving one of these errors.", 
            "title": "Return Value"
        }, 
        {
            "location": "/programming-reference/#remarks_7", 
            "text": "This function is used to send channel protocol to the server. The engine\neither accepts all the data, or refuses it all, in which case the\nchannel will need to retry later (normally inside DriverPoll).  The address for this function is obtained from the VDWRITEHOOKEX\nstructure after hook registration in pSendDataProc. The VDWRITEHOOK\nstructure provides pWd.", 
            "title": "Remarks"
        }, 
        {
            "location": "/programming-reference/#icadataarrival", 
            "text": "The WinStation driver calls this function when data is received on a\nvirtual channel being monitored by the driver. The address of this\nfunction is passed to the WinStation driver during DriverOpen.", 
            "title": "ICADataArrival"
        }, 
        {
            "location": "/programming-reference/#calling-convention_8", 
            "text": "VOID wfcapi ICADataArrival(\n    PVD pVD,\n    USHORT uchan,\n    LPBYTE pBuf,\n    USHORT Length);", 
            "title": "Calling Convention"
        }, 
        {
            "location": "/programming-reference/#parameters_8", 
            "text": "Parameter  Description      pVD  Pointer to a virtual driver control structure.    uChan  Virtual channel number.    pBuf  Pointer to the data buffer containing the virtual channel data as sent by the server-side application.    Length  Length in bytes of the data in the buffer.", 
            "title": "Parameters"
        }, 
        {
            "location": "/programming-reference/#return-value_5", 
            "text": "No value is returned from this function.", 
            "title": "Return Value"
        }, 
        {
            "location": "/programming-reference/#remarks_8", 
            "text": "This function name is a placeholder for a user-defined function; the\nactual function does not have to be called ICADataArrival, although it\ndoes have to match the function signature (parameters and return type).\nThe address of this function is given to the WinStation driver during\nDriverOpen. Although ICA prefixes packet control data to the virtual\nchannel data, this prefix is removed before this function is called.  After the virtual driver returns from this function, the WinStation\ndriver considers the data de livered. The virtual driver must save\nwhatever information it needs from this packet if later processing is\nrequired.  Do not allow this function to block. Use your own thread or the\nDriverPoll function (with polling enabled) for any required deferred\nprocessing.  The virtual driver can send data to the server on receipt of this data\nfrom within the ICADataArrival function, but be aware that the send\noperation may return an immediate error when buffers are not available\nto accommodate the send operation. The virtual driver may not block in this\nfunction waiting for the sending operation to complete.  If the virtual driver is handling multiple virtual channels, use the\nuChan parameter to determine the channel over which this data is to be\nsent. See DriverOpen for more information.", 
            "title": "Remarks"
        }, 
        {
            "location": "/programming-reference/#migetprivateprofilebool", 
            "text": "Gets a Boolean value from a section of the Configuration Storage.", 
            "title": "miGetPrivateProfileBool"
        }, 
        {
            "location": "/programming-reference/#calling-convention_9", 
            "text": "INT miGetPrivateProfileBool(\n    PCHAR lpszSection,\n    PCHAR lpszEntry,\n    BOOL bDefault);", 
            "title": "Calling Convention"
        }, 
        {
            "location": "/programming-reference/#parameters_9", 
            "text": "Parameter  Description      lpsz Section  Name of section to query.    lpsz Entry  Name of entry to query.    bDefault  Default value to use.", 
            "title": "Parameters"
        }, 
        {
            "location": "/programming-reference/#return-values_3", 
            "text": "If the requested entry is found, the entry value is returned; otherwise, bDefault  is returned.", 
            "title": "Return Values"
        }, 
        {
            "location": "/programming-reference/#remarks_9", 
            "text": "A Boolean value of TRUE can be represented by on, yes, or true in the\nconfiguration files. All other strings are interpreted as FALSE.", 
            "title": "Remarks"
        }, 
        {
            "location": "/programming-reference/#migetprivateprofileint", 
            "text": "Gets an integer from a section of the Configuration Storage.", 
            "title": "miGetPrivateProfileInt"
        }, 
        {
            "location": "/programming-reference/#calling-convention_10", 
            "text": "INT miGetPrivateProfileInt(\n    PCHAR lpszSection,\n    PCHAR lpszEntry,\n    INT iDefault);\n\n\n### Parameters \n| Parameter | Description |\n|-----------|-------------|\n| lpsz Section | Name of section to query. |\n| lpsz Entry | Name of entry to query. |\n| iDefault | Default value to use. |\n\n\n### Return Values\n\nIf the requested entry is found, the entry value is returned; otherwise,\niDefault is returned.\n\n## miGetPrivateProfileLong\n\nGets a long value from a section of the configuration files.\n\n### Calling Convention  INT miGetPrivateProfileLong(\n    PCHAR lpszSection,\n    PCHAR lpszEntry,\n    LONG lDefault);  ### Parameters \n\n| Parameter | Description |\n|-----------|-------------|\n| lpsz Section | Name of section to query. |\n| lpsz Entry | Name of entry to query. |\n| iDefault | Default value to use. |\n\n### Return Values\n\nIf the requested entry is found, the entry value is returned; otherwise,\nlDefault is returned.\n\n\n## miGetPrivateProfileString\n\nGets a string from a section of the configuration files.\n\n### Calling Convention  INT miGetPrivateProfileString(\n    PCHAR lpszSection,\n    PCHAR lpszEntry,\n    PCHAR lpszDefault,\n    PCHAR lpszReturnBuffer, INT cbSize);  ### Parameters\n\n| Parameter | Description |\n|-----------|-------------|\n| lpsz Section | Name of section to query. |\n| lpsz Entry | Name of entry to query. |\n| lpsz Default | Default value to use. |\n| lpsz Return Buffer | Pointer to a buffer to hold results. |\n| cb Size | Size of lpszReturnBuffer in bytes. |\n\n\n### Return Values\n\nThis function returns the string length of the value returned in\nlpszReturnBuffer (not including the trailing NULL).\n\nIf the requested entry is found and the size of the entry string is less\nthan or equal to cbSize, the entry value is copied to lpszReturnBuffer;\notherwise, iDefault is copied to lpszReturnBuffer.\n\n### Remarks\n\nlpszDefault must fit in lpszReturnBuffer. The caller is responsible for\nallocating and deallocating lpszReturnBuffer.\n\nlpszReturnBuffer must be large enough to hold the maximum length entry\nstring, plus a NULL termination character. If an entry string does not\nfit in lpszReturnBuffer, the lpszDefault value is used.\n\n\n## QueueVirtualWrite\n\nA QueueVirtualWrite is an improved scatter gather interface. It queues a\nvirtual write and stimulates packet output if required allowing data to\nbe sent without having to wait for the poll.\n\n### Calling Convention  int WFCAPI\nQueueVirtualWrite ( \nPWD pWd,\nSHORT Channel,\nLPMEMORY_SECTION pMemorySections, \nUSHORT NrOfSections,\nUSHORT Flag);  ### Parameters\n\n| Parameter | Description |\n|-----------|-------------|\n| pWd | Pointer to a WinStation driver control structure. |\n| Channel | The virtual channel number |\n| pMemory Sections | Pointer to an array of one or more elements of the structure MEMORY_SECTION (see below) containing the pure body of the protocol, i.e. excluding the virtual write header defining the channel and the length. This will get constructed by the QueueVirtualWrite function itself. Normally the protocol body will already be in a single contiguous block of memory. But if not, then multiple sections can be defined, and the destination function will copy all the different pieces into the appropriate internal WD queue.\n| Number Of Sections | The number of memory sections, normally 1. |\n| Flush Control | Indicates whether a \u2018flush to wire\u2019 operation should be triggered after the data has been successfully queued. If this value is FLUSH_IMMEDIATELY, then if the line conditions permit, the WD will attempt to send this new virtual write immediately over the wire, after also flushing any earlier queued data for the same or higher priority. If the data is not time critical (within the span of about 50ms), it may be better not to force a flush at this point, so that the data (if small) may go over the wire together with other data, so making better use of the wire bandwidth. The value to use if an immediate flush is not required is !FLUSH_IMMEDIATELY. |\n\n### Memory section\n\nThis structure has the definition:  typedef struct _MEMORY_SECTION\n{\n    UINT lenght;                        //Length of data\n    LPBYTE pSection;                    //Address of data\n}   MEMORY SECTION,     far * LPMEMORY SECTION;  ### Return Values\n\nIf the function succeeds, it returns CLIENT_STATUS_SUCCESS. If it\ncannot currently accept the data, it returns CLIENT_ERROR_NO_OUTBUF.\nIf being called from DriverPoll, then the return value for the\nDriverPoll should normally be set to CLIENT_STATUS_ERROR_RETRY in\nthis case. If the function fails, it returns an error code associated\nwith the failure; use GetLastError to get the extended error\ninformation.\n\n### Remarks\n\nThis function is used to send channel protocol to the server. The engine\neither accepts all the data, or refuses it all, in which case the\nchannel will need to retry later (normally inside DriverPoll).\n\nThe address for this function is obtained from the VDWRITEHOOK structure\nafter hook Registration in pQueueVirtualWriteProc. The VDWRITEHOOK\nstructure also provides pWd. Each successful call will ultimately result\nin a single block of protocol, with length = total length of all memory\nsections, being delivered to the server-side channel.\n\n## VdCallWd\n\nCalls the client WinStation driver to query and set information about\nthe virtual channel. This is the main method for the virtual driver to\naccess the WinStation driver. For general-purpose virtual channel\ndrivers, this sets the virtual write hook.\n\n### Calling Convention  INT VdCallWd (\nPVD pVd,\nUSHORT ProcIndex,\nPVOID pParam);  ### Parameters\n\n| Parameter | Description |\n|-----------|-------------|\n| pVd | Pointer to a virtual driver control structure. |\n| Proc Index | Index of the WinStation driver routine to call. For virtual drivers, this can be either `WDxQUERYINFORMATION` or `WDxSETINFORMATION`.|\n| pParam | Pointer to a parameter structure. |\n\n\n### Return Values\n\nIf the function succeeds, it returns CLIENT_STATUS_SUCCESS.\n\nIf the function fails, it returns an error code associated with the\nfailure; use DriverGetLastError to get the extended error information.\n\n### Remarks\n\nThis function is a general purpose mechanism to call routines in the\nWinStation driver. The only valid uses of this function for a virtual\ndriver are to:.\n\n* To allocate the virtual channel using WDxQUERYINFORMATION\n* To exchange function pointers with the\nWinStation driver during DriverOpen using WDxSETINFORMATION\n\nFor more information, see DriverOpen or the Ping example.\n\nOn successful return, the VDWRITEHOOK structure contains pointers to the\noutput buffer virtual driver helper functions, and a pointer to the\nWinStation driver control block (which is needed for buffer calls).\n\n## WFVirtualChannelClose\n\nCloses an open virtual channel handle.\n\n### Calling Convention  BOOL WINAPI WFVirtualChannelClose(IN HANDLE hChannelHandle);  ### Parameter\n\n| Parameter | Description |\n|-----------|-------------|\n| hChannel Handle | Handle to a previously opened virtual channel. Use WFVirtualChannelOpen to obtain a handle for a specific channel. |\n\n\n### Return Values\n\nIf the function succeeds, the return value is TRUE. If the function\nfails, the return value is FALSE; call GetLastError to get extended\nerror information.\n\n### Remarks\n\nWhen this function is called, any data waiting to be sent to the client\nis discarded. Call this function when the server-side virtual channel\napplication is finished.\n\nThe client- side virtual driver is not closed until the ICA session is\nclosed. If the virtual driver sends data to the server after the\nserver-side application closes, the data is queued on the server and\neventually discarded.\n\nTo prevent the virtual driver from sending data after the server-side\napplication closes, you might need to incorporate a packet type into\nyour virtual channel protocol to notify the virtual driver that the\nserver-side application is closing.\n\n## WFVirtualChannelOpen\n\nOpens a handle to a specific virtual channel.\n\n### Calling Convention  HANDLE WINAPI WFVirtualChannelOpen(IN HANDLE hServer, \n                                    IN DWORD SessionId,\n                                    IN LPSTR pVirtualName // ANSI name \n                                    );  ### Parameters\n\n| Parameter | Description |\n|-----------|-------------|\n| hServer | Handle to a server running XenApp. To specify the current server, use the constant WF_CURRENT_SERVER_HANDLE. Use WFOpenServer to obtain a handle for a specific server. For more information about the WFOpenServer function, see the WFAPI SDK documentation. |\n| Session Id | Server session ID. Use the constant WF_CURRENT_SESSION to specify the current session. To obtain the session ID of a specific session, use WFEnumerateSessions. For more information about session IDs and WFEnumerateSessions, see the WFAPI SDK documentation. |\n| pVirtual Name | Pointer to the virtual channel name. This is an ASCII string (even when Unicode is defined) of no more than seven characters.\n\n\n### Return Values\n\nIf the function succeeds, it returns a handle to the specified virtual\nchannel. If the function fails, it returns NULL; call GetLastError for\nextended error information.\n\n### Remarks\n\nThe WinStation driver opens the channel by name, assigns a channel\nnumber, and returns a handle. The server -side virtual channel\napplication uses this handle to read and write data to the virtual\nchannel.\n\n## WFVirtualChannelPurgeInput\n\nPurges all queued input data sent from the client to the server on a\nspecific virtual channel.\n\n### Calling Convention  BOOL WINAPI WFVirtualChannelPurgeInput(IN HANDLE hChannelHandle);  ### Parameter\n\n| Parameter | Description |\n|-----------|-------------|\n| hChannel Handle | Handle to a previously opened virtual channel. To obtain a handle for a specific channel, use WFVirtualChannelOpen. |\n\n### Return Values\n\nIf the function succeeds, the return value is TRUE. If the function\nfails, the return value is FALSE; call GetLastError to get extended\nerror information.\n\n### Remarks\n\nOutput buffers and queued data received from the client are discarded.\n\nThis function sends a message to the client WinStation driver, which\nthen calls the client virtual driver\u2019s\n\nDriverSetInformation function with the VdFlush information class. For\nmost virtual channels, this function is not necessary and you can use\nthe Ping example function without modification.\n\n## WFVirtualChannelPurgeOutput\n\nPurges all queued output data sent from the server to the client on a\nspecific virtual channel.\n\nExample of use: in an audio application in which the user starts playing\na different audio file, use this function to discard the audio that was\nqueued to be sent to the client from the first file played.\n\n### Calling Convention  BOOL WINAPI WFVirtualChannelPurgeOutput(IN HANDLE hChannelHandle);  ###   Parameter  |   Parameter   |   Description   |  |-----------|-------------|  |   hChannel   Handle   |   Handle   to   a   previously   opened   virtual   channel .   To   obtain   a   handle   for   a   specific   channel ,   use   WFVirtualChannelOpen .   |  ###   Return   Values  If   the   function   succeeds ,   the   return   value   is   TRUE .   If   the   function  fails ,   the   return   value   is   FALSE .   Call   GetLastError   to   get   extended  error   information .  ###   Remarks  Output   buffers   and   data   queued   to   be   sent   to   the   client   are   discarded .  This   function   sends   a   message   to   the   client   WinStation   driver ,   which  then   calls   th   e   client   virtual   driver \u2019 s   DriverSetInformation   function  with   the   VdFlush   information   class .   For   most   virtual   channels ,   this  function   is   not   necessary   and   you   can   use   the   Ping   example   function  without   modification .  ##   WFVirtualChannelQuery  Returns   data   related   to   a   virtual   channel .   This   information   is   obtained  when   the   ICA   connection   is   initiated   and   the   WinStation   driver   calls   the  DriverInfo   function .  ###   Calling   Convention   BOOL WINAPI WFVirtualChannelQuery(IN HANDLE hChannelHandle,\n                                   IN WF_VIRTUAL_CLASS VirtualClass, \n                                   OUT PVOID *ppBuffer,\n                                   OUT DWORD *pBytesReturned \n                                   );  ### Parameters\n\n| Parameter | Description |\n|-----------|-------------|\n| hChannel Handle | Handle to a previously opened virtual channel. To obtain a handle for a specific channel, use WFVirtualChannelOpen. |\n| Virtual Class | Type of information to request. Currently, the only defined value is WFVirtualClientData , which returns virtual channel client module data. |\n| ppBuffer | Pointer to the address of a variable to receive the data. The buffer is allocated within this fun ction and is deallocated by using WFFreeMemory. |\n| pBytes Returned | Pointer to a DWORD that is updated with the length of the data returned in the allocated buffer (upon successful return). |\n\n### Return Values\n\nIf the function succeeds, the return value is TRUE. If the function\nfails, the return value is F ALSE; Call GetLastError to get extended\nerror information.\n\n### Remarks\n\nppBuffer begins with the structure VD_C2H, which begins with the\nstructure MODULE_C2H. These two structures are defined in Ica-c2h.h (in\nsrc\\inc\\). See the Ping example for more information.\n\n## WFVirtualChannelRead\n\nReads data from a virtual channel. \n\n### Calling Convention  BOOL WINAPI WFVirtualChannelRead(IN HANDLE hChannelHandle,\n                                  IN ULONG TimeOut, \n                                  OUT PCHAR pBuffer, \n                                  IN ULONG BufferSize,\n                                  OUT PULONG pBytesRead\n                                  );  ###   Parameters  |   Parameter   |   Description   |  |-----------|-------------|  |   hChannel   Handle   |   Handle   to   a   previously   opened   virtual   channel .   To   obtain   a   handle   for   a   specific   channel ,   use   WFVirtualChannelOpen .   |  |   TimeOut   |   Length   of   time   to   wait   for   data   ( in   milliseconds ).   If   this   value   is   zero ,   the   function   returns   immediately   whether   or   not   data   is   available .   If   this   value   is   - 1 ,   the   function   continues   waiting   until   there   is   data   to   read .   |  |   pBuffer   |   Buffer   to   receive   the   data   read   from   the   virtual   channel .   |  |   Buffer   Size   |   Size   in   bytes   of   the   buffer   needed .   |  |   pBytes   Read   |   Pointer   to   a   variable   that   receives   the   number   of   bytes   read .   |  ###   Return   Values  If   the   function   succeeds ,   the   return   value   is   TRUE .   If   the   function  fails ,   the   return   value   is   FALSE ;   call   GetLastError   to   get   extended  error   information .  ###   Remarks  The   developer   determines   the   BufferSize ,   which   can   be   any   length   up   to  the   maximum   size   supported   by   the   ICA   connection .   This   size   is  independent   of   size   restrictions   on   the   lower - layer   transport .  *   If   the   server   is   running   XenApp ,   the  maximum   packet   size   is   5000   bytes   ( 4996   bytes   of   data   plus   the   4 - byte  packet   overhead   generated   by   the   ICA   datastream   manager ).  If   more   data   is   received   than   the   buffer   can   hold ,   the   entire   packet   is  discarded .  If   no   data   is   received ,   pBuffer   and   pBytesRead   are   unmodified .   The  function   fails   if   the   read   times   out .  The   server - side   virtual   channel   application   is   not   notified   when   data   is  received .   Instead ,   the   data   is   queued   until   the   application   uses  WFVirtualChannelRead   to   retrieve   it .  ##   WFVirtualChannelWrite  Writes   data   to   a   virtual   channel .  ###   Calling   Convention   BOOL WINAPI WFVirtualChannelWrite   (IN HANDLE hChannelHandle,\n                                     IN PCHAR pBuffer, \n                                     IN ULONG Length,\n                                     OUT PULONG pBytesWritten\n                                     );  ```", 
            "title": "Calling Convention"
        }, 
        {
            "location": "/programming-reference/#parameters_10", 
            "text": "Parameter  Description      hChannel Handle  Handle to a previously opened virtual channel. To obtain a handle for a specific channel, use WFVirtualChannelOpen.    pBuffer  Buffer containing data to write to the virtual channel. This must be four bytes larger than the largest buffer written by the client.    Length  Size in bytes of the buffer needed. This must be four bytes larger than the data written by the application.    pBytes Written  Pointer to a ULONG variable that receives the number of bytes written.", 
            "title": "Parameters"
        }, 
        {
            "location": "/programming-reference/#return-values_4", 
            "text": "If the data is sent, the return value is TRUE.  If the data is not sent, the return value is FALSE; call GetLastError to\nget extended error information.", 
            "title": "Return Values"
        }, 
        {
            "location": "/programming-reference/#remarks_10", 
            "text": "The developer determines the Length, which can be any length up to the\nmaximum size supported by the ICA connection. This size is independent\nof size restrictions on the lower-layer transport.   If the server is running XenApp, the\nmaximum packet size is 5000 bytes (4996 bytes of data plus the 4-byte\npacket overhead generated by the ICA datastream manager).   The WinStation driver calls the client virtual driver's ICADataArrival\nfunction.", 
            "title": "Remarks"
        }
    ]
}